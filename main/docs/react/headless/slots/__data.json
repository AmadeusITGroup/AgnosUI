{"type":"data","nodes":[null,{"type":"data","data":[{"includesFwk":1,"menu":2},true,[3,16,33,56,82],{"title":4,"submenu":5},"Getting started",[6,10,13],{"label":7,"status":8,"path":9,"subpath":8},"Introduction","","docs/react/getting-started/introduction",{"label":11,"status":8,"path":12,"subpath":8},"Features","docs/react/getting-started/features",{"label":14,"status":8,"path":15,"subpath":8},"Installation","docs/react/getting-started/installation",{"title":17,"submenu":18},"Headless",[19,21,24,27,30],{"label":7,"status":8,"path":20,"subpath":8},"docs/react/headless/introduction",{"label":22,"status":8,"path":23,"subpath":8},"Configuration","docs/react/headless/configuration",{"label":25,"status":8,"path":26,"subpath":8},"Slots","docs/react/headless/slots",{"label":28,"status":8,"path":29,"subpath":8},"Directives","docs/react/headless/directives",{"label":31,"status":8,"path":32,"subpath":8},"Implementation","docs/react/headless/implementation",{"title":34,"submenu":35},"DaisyUI",[36,41,44,47,50,53],{"label":37,"status":38,"path":39,"subpath":40},"Alert","stable","docs/react/daisyUI/alert/","headless",{"label":42,"status":38,"path":43,"subpath":40},"Pagination","docs/react/daisyUI/pagination/",{"label":45,"status":38,"path":46,"subpath":40},"Progressbar","docs/react/daisyUI/progressbar/",{"label":48,"status":38,"path":49,"subpath":40},"Rating","docs/react/daisyUI/rating/",{"label":51,"status":38,"path":52,"subpath":40},"Slider","docs/react/daisyUI/slider/",{"label":54,"status":38,"path":55,"subpath":40},"Toast","docs/react/daisyUI/toast/",{"title":57,"submenu":58},"Components",[59,63,65,68,70,72,74,78,80],{"label":60,"status":38,"path":61,"subpath":62},"Accordion","docs/react/components/accordion/","examples",{"label":37,"status":38,"path":64,"subpath":62},"docs/react/components/alert/",{"label":66,"status":38,"path":67,"subpath":62},"Modal","docs/react/components/modal/",{"label":42,"status":38,"path":69,"subpath":62},"docs/react/components/pagination/",{"label":45,"status":38,"path":71,"subpath":62},"docs/react/components/progressbar/",{"label":48,"status":38,"path":73,"subpath":62},"docs/react/components/rating/",{"label":75,"status":76,"path":77,"subpath":62},"Select","inprogress","docs/react/components/select/",{"label":51,"status":38,"path":79,"subpath":62},"docs/react/components/slider/",{"label":54,"status":38,"path":81,"subpath":62},"docs/react/components/toast/",{"title":83,"submenu":84},"Services",[85,87,90,93,96,99],{"label":7,"status":8,"path":86,"subpath":8},"docs/react/services/introduction",{"label":88,"status":8,"path":89,"subpath":8},"Focustrack","docs/react/services/focustrack",{"label":91,"status":8,"path":92,"subpath":8},"Floating UI","docs/react/services/floating-ui",{"label":94,"status":8,"path":95,"subpath":8},"Resize Observer","docs/react/services/resize-observer",{"label":97,"status":8,"path":98,"subpath":8},"Transition","docs/react/services/transition",{"label":100,"status":8,"path":101,"subpath":8},"Match Media","docs/react/services/match-media"],"uses":{"params":["framework"]}},{"type":"data","data":[{"slug":1,"prev":2,"next":9,"content":14,"since":8},"headless/slots",{"slug":3,"content":4,"title":5,"subpath":6,"status":6,"attributes":7},"headless/configuration","# Configuration\n\n## Overview\n\nWe call **Configuration** the AgnosUI system to set the default state of widgets deeply in the application tree.  \nThis is usually referred as **context injection** and is handy to configure a part of a web application, without having to pass properties down the chain.\n\nYou can check how each framework handles this need on their respective documentation:\n\n\u003Cul>\n    \u003Cli>\u003Ca href=\"https://svelte.dev/docs/svelte#setcontext\" target=\"_blank\">setContext in Svelte\u003C/a>\u003C/li>\n    \u003Cli>\u003Ca href=\"https://react.dev/learn/passing-data-deeply-with-context\" target=\"_blank\">passing data deeply in React\u003C/a>\u003C/li>\n    \u003Cli>\u003Ca href=\"https://angular.io/guide/creating-injectable-service\" target=\"_blank\">context injection in Angular\u003C/a>\u003C/li>\n\u003C/ul>\n\nThe configuration is available out of the box as soon as widgets are created using the AgnosUI headless factories.  \nThe headless packages also provide utilities for each framework to retrieve and update widget configuration.\n\n## In Action\n\nOne of the most use cases of configuration is setting a default config for multiple sibling widgets.  \nLet's see it in action, using the Bootstrap flavour of the **Alert** component:\n\n```sample\n{Configuration:configuration/basic:278}\n```\n\nThe Configuration is then used by all children with the modified state, as shown below:\n\n```sample\n{Configuration:configuration/down:278}\n```\n","Configuration","",{"since":8},"0.1.1",{"slug":10,"content":11,"title":12,"subpath":6,"status":6,"attributes":13},"headless/directives","# Directives\n\n## Overview\n\nDirectives in AgnosUI are inspired by the **actions** in Svelte. These directives are element-level lifecycle functions that are executed when the element is created. They are updated (if an update function is provided) when a parameter changes, and finally, they are executed when the element is destroyed.\nThese directives are typically used to add custom event handlers. For instance, core services like [focus track](../04-Services/01-Focustrack.md) and [floating ui](../04-Services/03-Floating-UI.md) create directives that are utilized by components such as [Select](../components/select/examples).\n\n## Usage\n\nThe usage of this function is dependent on the JavaScript framework (if any) that the application utilizes. For instance, in this guide, we are using simple TypeScript without any specific framework.\n\n### How to create a directive\n\nA directive is a function that takes as input an `HTMLElement` and an optional parameter, for example an object representing a configuration.\nThis function will execute a first time when the directive is applied to an element (usually when the DOM element is created) and either it returns `void`, or 2 optional functions:\n\n- `update` function, called when the context changed and you need either to update the directive configuration or to re-execute partially the original function or modify some internal state of the directive.\n- `destroy` function, used to remove eventual listeners, subscriptions or any reactive objects created by the directive. This function is usually called when the DOM element on which you applied the directive gets removed from the DOM.\n\n```typescript\nconst createSampleDirective: Directive\u003Cstring> = (element: HTMLElement, text: string) => {\n\tconsole.log('Directive has been executed on node ', element.id);\n\tconst clickListener = (event: Event) => {\n\t\tconsole.log(text, event.target);\n\t};\n\telement.addEventListener('click', clickListener);\n\treturn {\n\t\tupdate: (newText) => (text = newText),\n\t\tdestroy: () => {\n\t\t\telement.removeEventListener('click', clickListener);\n\t\t\tconsole.log('Destroy function executed ', element.id);\n\t\t},\n\t};\n};\n```\n\nThis example shows a very simple directive that creates an event listener on `click` events that happen on the HTML element and then print the parameter `text` in the console, along with the clicked target.\n\nBoth `update` and `destroy` functions are provided by the directive, as following:\n\n- `update`: gives a way to modify the original text to something new, when the context changes (see in the next section).\n- `destroy`: remove the previously created listener, so that you don't bloat the main thread with unused listeners.\n\n### How to use a directive\n\nConsidering this HTML page, in which you have a `div` container `focus-element` that includes 2 `button`, an input text `clickText` and another `button` that removes the container.\n\n```html\n\u003Cdiv id=\"content\">\n\t\u003Cdiv id=\"focus-element\">\n\t\t\u003Cbutton>button 1\u003C/button>\n\t\t\u003Cbutton>button 2\u003C/button>\n\t\u003C/div>\n\t\u003Chr />\n\t\u003Cinput id=\"clickText\" type=\"text\" />\n\t\u003Chr />\n\t\u003Cbutton onclick=\"document.getElementById('focus-element').remove()\">remove dom element\u003C/button>\n\u003C/div>\n```\n\nTo use the directive in vanilla TS you need the following steps:\n\n1.  Create the directive on a DOM element. In this case, our elementwill be the `focus-element` container.\n\n    ```typescript\n    const trackElement = document.getElementById('focus-element');\n    const focusElementDirective = createSampleDirective(trackElement, 'focus-element click');\n    ```\n\n    When the browser loads, you will get the following log, since the directive executes a first time and it creates its event listener.\n\n    ```\n    Directive has been executed on node focus-element\n    ```\n\n    If you click on `button 1`, the listener triggers `clickListener` function and you get a log into the console:\n\n    ```\n    focus element clicked \u003Cbutton>​button 1​\u003C/button>​\n    ```\n\n    Same if you click on `button 2`, since it also belongs to the element `focus-element` on which we applied the directive.\n\n    ```\n    focus element clicked \u003Cbutton>​button 2\u003C/button>​\n    ```\n\nChanging the input does not change anything, because the `update` function has no bindings and it is never called. To solve it, we need the next step.\n\n2.  Observe context changes and call the `update` function accordingly. For example, we want to change the text to the value of the `clickText` input when it changes.\n\n    ```typescript\n    const input = document.getElementById('clickText');\n    input.addEventListener('change', (event) => {\n    \tfocusElementDirective?.update(event.target.value);\n    });\n    ```\n\n    Now we bound the directive `update` function to a change event on the input `clickText`.\n    Type `Update has been called!` in the input and then click again on `button 1`, you get:\n\n    ```\n    Update has been called! \u003Cbutton>​button 1\u003C/button>​\n    ```\n\n    The directive has been correctly updated according to the context change.\n    The last life-cycle event to implement will be the destroy.\n\n3.  Clean up when the `focus-element` gets remove from the DOM. This can be done for example using a `MutationObserver` on the parent DOM element.\n\n    ```typescript\n    const cleanup = (mutations: MutationRecord[]) => {\n    \tmutations.forEach((mutation) => {\n    \t\tfor (let entry of mutation.removedNodes.entries()) {\n    \t\t\tif (entry.includes(trackElement)) {\n    \t\t\t\tfocusElementDirective?.destroy();\n    \t\t\t}\n    \t\t}\n    \t});\n    };\n    const observer = new MutationObserver(cleanup);\n    observer.observe(document.getElementById('content'), {childList: true});\n    ```\n\n    Click on `remove dom element`, that remove completely the `focus-element` container from the DOM. Last log will be printed:\n\n    ```\n    Destroy function executed  focus-element\n    ```\n\n### Frameworks usage\n\nAs seen in the previous section, a `Directive` is framework agnostic. But the way frameworks expose the DOM element and binds life-cycle events can be very different. Frameworks controls life-cycle events of the DOM elements, in particular initialization, updates and destroy.\n\nThe headless libraries of AgnosUI contain adapters to bind directives in the correct way, so that the corresponding events are called at the right moment benefiting from framework features.\n\n\u003C!-- \u003Cframework-specific src=\"Directives.md\"> -->\n\n[Directives in Angular](../../angular/docs/Directives.md),\n[Directives in React](../../react/docs/Directives.md),\n[Directives in Svelte](../../svelte/docs/Directives.md)\n\n\u003C!-- \u003C/framework-specific> -->\n\n## Advanced\n\n### Merge directives\n\nIf you are using Svelte, you can have multiple directives by using multiple time the `use` directive. On other frameworks, this is not the case.\nAgnos has a utility `mergeDirectives` to merge directives into one, with a limitation on the argument:\nall directives receive the same argument upon initialization and update.\nDirectives are created and updated in the same order as they appear in the arguments list,\nthey are destroyed in the reverse order.\nAll calls to the directives (to create, update and destroy them) are wrapped in a call to the batch function of tansu\n\nUse directly the `mergeDirectives` function in an Angular component to merge directives are pass them as input to the Angular directive `auUse`. For React, there is a version `useDirectives` instead of the singular one to manage this use case.\n","Directives",{"since":8},"# Slots\n\n## What are Slots ?\n\nSlots are essentially placeholders within a component that can be filled with custom content.\nThey provide a way to dynamically inject content into a component without affecting its original template.  \nThis makes it possible to create components that can be easily adapted to different scenarios without having to duplicate code or create a new component from scratch.\n\n## Why use them ?\n\nSlots facilitate the creation of more versatile and reusable components.\nThey allow developers to design components with predefined structures while leaving room for variation in content.  \nThis separation of structure and content enhances code reusability and promotes a cleaner, more modular codebase.\n\n## AgnosUI Slot\n\nAgnosUI core widgets include slots as **properties** prefixed by _slot_ in their states.  \nThis allows to specifiy the projected content in multiple manners, like simple `string`, context-aware functions, standard slots or even fully-fledged components.\n\nTo illustrate the basic usage, let's see in action how we can use a simple slot in the Bootstrap flavour of the **Alert** component:\n\n```sample\n{Slot Standard Usage:slots/usage:278}\n```\n\n## Context\n\nSlots have access to a context, which for most cases is the widget state.  \nIt is possible however to extend the context, which enables powerful customization. Here is an example with the Bootstrap flavour of the **Pagination** component:\n\n```sample\n{Slot Context:slots/context:220}\n```\n\n## Integration with Configuration\n\nAs explained above, AgnosUI slots are inherently properties, thus benefit from the [Configuration](01-Configuration.md).  \nFor instance, we may configure the _slotStructure_ of the **Alert** to use a custom component, allowing to fully customize the widget.\n\n```sample\n{Slot Configuration:alert/icon:402}\n```\n\n## Slots in React\n\nReact manages slots using the `children` specific property, as [documented here](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children).  \nWe support this behavior, while going further.\n\nThe AgnosUI React slots can be set using:\n\n- a simple `string`\n- a function `(props: Props) => string`\n- a React node\n- a function `(props: Props) => React.ReactNode` returning a React node\n- a React class or function component\n\n\n## Headless example\n\nYou can check out the following example, re-writing the Bootstrap flavour of the **Rating** component as readonly:\n\n```sample\n{Slot Headless:slots/headless:148}\n```\n"],"uses":{"params":["slug","framework"]}}]}
