{"type":"data","nodes":[null,{"type":"data","data":[{"includesFwk":1,"menu":2},true,[3,16,33,53,81],{"title":4,"submenu":5},"Getting started",[6,10,13],{"label":7,"status":8,"path":9,"subpath":8},"Introduction","","docs/svelte/getting-started/introduction",{"label":11,"status":8,"path":12,"subpath":8},"Features","docs/svelte/getting-started/features",{"label":14,"status":8,"path":15,"subpath":8},"Installation","docs/svelte/getting-started/installation",{"title":17,"submenu":18},"Headless",[19,21,24,27,30],{"label":7,"status":8,"path":20,"subpath":8},"docs/svelte/headless/introduction",{"label":22,"status":8,"path":23,"subpath":8},"Configuration","docs/svelte/headless/configuration",{"label":25,"status":8,"path":26,"subpath":8},"Slots","docs/svelte/headless/slots",{"label":28,"status":8,"path":29,"subpath":8},"Directives","docs/svelte/headless/directives",{"label":31,"status":8,"path":32,"subpath":8},"Implementation","docs/svelte/headless/implementation",{"title":34,"submenu":35},"DaisyUI",[36,41,44,47,50],{"label":37,"status":38,"path":39,"subpath":40},"Alert","stable","docs/svelte/daisyUI/alert/","headless",{"label":42,"status":38,"path":43,"subpath":40},"Pagination","docs/svelte/daisyUI/pagination/",{"label":45,"status":38,"path":46,"subpath":40},"Progressbar","docs/svelte/daisyUI/progressbar/",{"label":48,"status":38,"path":49,"subpath":40},"Rating","docs/svelte/daisyUI/rating/",{"label":51,"status":38,"path":52,"subpath":40},"Slider","docs/svelte/daisyUI/slider/",{"title":54,"submenu":55},"Components",[56,60,62,65,68,70,72,76,78],{"label":57,"status":38,"path":58,"subpath":59},"Accordion","docs/svelte/components/accordion/","examples",{"label":37,"status":38,"path":61,"subpath":59},"docs/svelte/components/alert/",{"label":63,"status":38,"path":64,"subpath":59},"Modal","docs/svelte/components/modal/",{"label":42,"status":66,"path":67,"subpath":59},"beta","docs/svelte/components/pagination/",{"label":45,"status":38,"path":69,"subpath":59},"docs/svelte/components/progressbar/",{"label":48,"status":38,"path":71,"subpath":59},"docs/svelte/components/rating/",{"label":73,"status":74,"path":75,"subpath":59},"Select","inprogress","docs/svelte/components/select/",{"label":51,"status":38,"path":77,"subpath":59},"docs/svelte/components/slider/",{"label":79,"status":66,"path":80,"subpath":59},"Toast","docs/svelte/components/toast/",{"title":82,"submenu":83},"Services",[84,86,89,92,95,98],{"label":7,"status":8,"path":85,"subpath":8},"docs/svelte/services/introduction",{"label":87,"status":8,"path":88,"subpath":8},"Focustrack","docs/svelte/services/focustrack",{"label":90,"status":8,"path":91,"subpath":8},"Floating UI","docs/svelte/services/floating-ui",{"label":93,"status":8,"path":94,"subpath":8},"Resize Observer","docs/svelte/services/resize-observer",{"label":96,"status":8,"path":97,"subpath":8},"Transition","docs/svelte/services/transition",{"label":99,"status":8,"path":100,"subpath":8},"Match Media","docs/svelte/services/match-media"],"uses":{"params":["framework"]}},{"type":"data","data":[{"slug":1,"prev":2,"next":9,"content":14,"since":8},"services/focustrack",{"slug":3,"content":4,"title":5,"subpath":6,"status":6,"attributes":7},"services/introduction","# Introduction to Services\n\n## Overview\n\nAgnosUI Services are pure Typescript utilities that handle problematics such as popovers or focus tracking in a reactive and framework-agnostic manner.  \nThey are provided in the core package, @agnos-ui/core, and can be used with or without the widgets.\n","Introduction","",{"since":8},"0.1.1",{"slug":10,"content":11,"title":12,"subpath":6,"status":6,"attributes":13},"services/floating-ui","# Floating UI\n\n## Service Overview\n\nThe Floating UI service is designed to create a flexible and dynamic floating DOM element that can be positioned relative to a reference element. It provides a set of options for customization, including positioning configuration, auto-updating behavior, and arrow styling.\n\nThe service uses a 3rd party library called [floating UI](https://floating-ui.com/).\n\nBy leveraging the provided directives and state stores, developers can easily integrate floating UI elements into their web applications with flexibility and control.\n\n## `createFloatingUI` factory\n\nUse the `createFloatingUI` function to create an instance of the Floating UI service.\nPass an optional `propsConfig` parameter to customize the initial configuration.\n\n### Configuration Options\n\nThe `propsConfig` parameter allows you to provide initial values for the following options:\n\n- **computePositionOptions** Option for positioning the floating UI relative to the reference element. Refer to [computePosition documentation](https://floating-ui.com/docs/computeposition#options) for defaults and options.\n- **autoUpdateOptions** Option for enabling auto-updating of the floating position. Refer to [autoUpdate documentation](https://floating-ui.com/docs/autoupdate#options) for defaults and options.\n- **arrowOptions** Option to customize the arrow element associated, by giving the element itself and eventually a padding. Refer to [arrow documentation](https://floating-ui.com/docs/arrow#options) for defaults and options.\n\n## Output Directives\n\n1. **Reference Directive** Apply this directive to the reference element from which the floating UI will be positioned.\n\n2. **Floating Directive** Apply this directive to the floating UI element. This directive includes styling updates based on the floating UI position.\n3. **Arrow Directive** Apply this directive to the arrow element, if present. This directive includes styling updates based on the arrow position.\n\n## State Stores\n\nThe Floating UI service exposes several state stores that represent different aspects of the UI position:\n\n- `x$`: X-coordinate of the floating UI.\n- `y$`: Y-coordinate of the floating UI.\n- `strategy$`: Strategy used for positioning.\n- `placement$`: Placement of the floating UI.\n- `middlewareData$`: Additional data provided by middleware.\n\n## Patching States\n\nFloating UI instance includes a `patch` method that allows you to patch the configuration dynamically at runtime.\n\n## Usage\n\n### In Action\n\n```sample\n{FloatingUI:floatingUI/floatingUI:500}\n```\n","Floating UI",{"since":8},"# Focus track\n\n## Motivation\n\nIn a web application, there is often a requirement to determine whether an element or any of its descendants currently has focus, typically for accessibility purposes. Developers commonly devise their own methods to track this information. In AgnosUI, we provide a utility in core services that AgnosUI components leverage for this purpose.\nUtilize the globally readable signal `activeElement$` to monitor the current focused item. If your focus is solely on your DOM element and its descendants, you have the option to generate a custom signal using the `HasFocus` factory.\n\n## Service Overview\n\nThis service exports functionality related to managing focus within a web application. It includes a readable signal, `activeElement$`, representing the currently active HTML element, and a factory function, `createHasFocus()`, that creates an object implementing the `HasFocus` interface.\n\nTo install the core part, open your project's terminal and run the following command:\n\n```bash\nnpm i @agnos-ui/core\n```\n\n### `activeElement$` Readable Signal\n\n`activeElement$` is a readable signal that provides information about the currently focused HTML element.\nWhen at least a consumer starts listening its value, it sets the active element to the current `document.activeElement`.\nThe active element is updated each time a `focusin`/ `focusout` event is triggered on the `document.documentElement`.\nThe event listeners are removed when the number of listeners fall to 0.\n\n### `createHasFocus` Factory\n\n`createHasFocus` is a factory function that creates an object conforming to the `HasFocus` interface.\nIt provides:\n\n- `directive` that can be apply to elements to track if the focus is on one of the elements or on one of their descendent.\n- `hasFocus$` signal (that internally uses the `activeElement$` signal) that say if the focus is actually among the elements (or their descendent) targeted by the directive.\n\n## Usage\n\nWhenever you want to check which element of the DOM has the focus, you can simply import the signal `activeElement$` and `subscribe` to it.\n\n### In action\n\n```sample\n{Focustrack:focustrack/focustrack:500}\n```\n\n### Example Usage `activeElement$`\n\n```typescript\nimport {activeElement$} from '@agnos-ui/core';}\n\nconst unsubscribe = activeElement$.subscribe((activeElement) => {\n\tconsole.log(`Tag name: ${activeElement?.tagName.toLowerCase()}, id: ${activeElement?.id}`);\n})\n```\n\n### Example Usage `HasFocus`\n\nIf you are only interested to your element and descendent, then you have to use the `createHasFocus` factory, apply the directive to the element, and then subscribe to the `hasFocus$` signal.\n\n```typescript\nimport {createHasFocus} from '@agnos-ui/core';\n\nconst {directive, hasFocus$} = createHasFocus();\n\n// Apply the directive to specific elements\n// (We provide utilities to apply this in the different framework context too)\nvar elementWhereToTrack = document.getElementById('id');\nconst instance = directive(elementWhereToTrack);\n\n// Subscribe to the hasFocus$ signal\nconst unsubscribe = hasFocus$.subscribe((hasFocus) => {\n\tconsole.log(`Focused: ${hasFocus}`);\n});\n\n// Cleanup\nunsubscribe();\ninstance?.destroy();\n```\n\n## Notes\n\n- The code ensures proper cleanup by removing event listeners when no longer needed.\n"],"uses":{"params":["slug","framework"]}}]}
