{"type":"data","nodes":[null,{"type":"data","data":[{"includesFwk":1,"includesPkg":1,"menu":2,"since":140},true,[3,6,9,12,51,94,113],{"title":4,"path":5,"submenu":-1},"Types","api/angular/headless/types",{"title":7,"path":8,"submenu":-1},"Config","api/angular/headless/config",{"title":10,"path":11,"submenu":-1},"Slot","api/angular/headless/slot",{"title":13,"path":-1,"submenu":14},"Components",[15,19,23,27,31,35,39,43,47],{"path":16,"slug":17,"label":18},"api/angular/headless/components/accordion","components/accordion","Accordion",{"path":20,"slug":21,"label":22},"api/angular/headless/components/alert","components/alert","Alert",{"path":24,"slug":25,"label":26},"api/angular/headless/components/modal","components/modal","Modal",{"path":28,"slug":29,"label":30},"api/angular/headless/components/pagination","components/pagination","Pagination",{"path":32,"slug":33,"label":34},"api/angular/headless/components/progressbar","components/progressbar","Progressbar",{"path":36,"slug":37,"label":38},"api/angular/headless/components/rating","components/rating","Rating",{"path":40,"slug":41,"label":42},"api/angular/headless/components/select","components/select","Select",{"path":44,"slug":45,"label":46},"api/angular/headless/components/slider","components/slider","Slider",{"path":48,"slug":49,"label":50},"api/angular/headless/components/toast","components/toast","Toast",{"title":52,"path":-1,"submenu":53},"Services",[54,58,62,66,70,74,78,82,86,90],{"path":55,"slug":56,"label":57},"api/angular/headless/services/extendWidget","services/extendWidget","extendWidget",{"path":59,"slug":60,"label":61},"api/angular/headless/services/floatingUI","services/floatingUI","floatingUI",{"path":63,"slug":64,"label":65},"api/angular/headless/services/focustrack","services/focustrack","focustrack",{"path":67,"slug":68,"label":69},"api/angular/headless/services/hash","services/hash","hash",{"path":71,"slug":72,"label":73},"api/angular/headless/services/intersection","services/intersection","intersection",{"path":75,"slug":76,"label":77},"api/angular/headless/services/matchMedia","services/matchMedia","matchMedia",{"path":79,"slug":80,"label":81},"api/angular/headless/services/navManager","services/navManager","navManager",{"path":83,"slug":84,"label":85},"api/angular/headless/services/portal","services/portal","portal",{"path":87,"slug":88,"label":89},"api/angular/headless/services/resizeObserver","services/resizeObserver","resizeObserver",{"path":91,"slug":92,"label":93},"api/angular/headless/services/siblingsInert","services/siblingsInert","siblingsInert",{"title":95,"path":-1,"submenu":96},"Transitions",[97,101,105,109],{"path":98,"slug":99,"label":100},"api/angular/headless/services/transitions/baseTransitions","services/transitions/baseTransitions","baseTransitions",{"path":102,"slug":103,"label":104},"api/angular/headless/services/transitions/collapse","services/transitions/collapse","collapse",{"path":106,"slug":107,"label":108},"api/angular/headless/services/transitions/cssTransitions","services/transitions/cssTransitions","cssTransitions",{"path":110,"slug":111,"label":112},"api/angular/headless/services/transitions/simpleClassTransition","services/transitions/simpleClassTransition","simpleClassTransition",{"title":114,"path":-1,"submenu":115},"Utils",[116,120,124,128,132,136],{"path":117,"slug":118,"label":119},"api/angular/headless/utils/coercion","utils/coercion","coercion",{"path":121,"slug":122,"label":123},"api/angular/headless/utils/directive","utils/directive","directive",{"path":125,"slug":126,"label":127},"api/angular/headless/utils/stores","utils/stores","stores",{"path":129,"slug":130,"label":131},"api/angular/headless/utils/widget","utils/widget","widget",{"path":133,"slug":134,"label":135},"api/angular/headless/utils/writables","utils/writables","writables",{"path":137,"slug":138,"label":139},"api/angular/headless/utils/zone","utils/zone","zone","v0.4.0"],"uses":{"params":["framework","type"]}},{"type":"data","data":[{"slug":1,"content":2,"title":54,"import":55},"utils/stores",[3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51],{"source":4,"name":5},"## function_bindableDerived\n> **bindableDerived**\\\u003C`T`, `U`\\>(`onChange$`, `stores`, `adjustValue`, `equal`): [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T`\\>\n\nCreates a writable signal that derives its value from multiple stores and allows for custom adjustment and equality checks.\n\n### Type Parameters\n\n• **T**\n\nThe type of the derived value.\n\n• **U** *extends* [[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T`\\>, `...StoreInput\u003Cany>[]`]\n\nA tuple type where the first element is a writable signal of type T and the rest are store inputs.\n\n### Parameters\n\n• **onChange$**: [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C(`value`) => `void`\\>\n\nA readable signal that emits a function to be called when the derived value changes.\n\n• **stores**: `U`\n\nA tuple of stores where the first element is a writable signal of type T and the rest are store inputs.\n\n• **adjustValue** = `...`\n\nA function to adjust the derived value based on the input values from the stores.\n\n• **equal** = `...`\n\nA function to compare the current and new values for equality.\n\n### Returns\n\n[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T`\\>\n\nA writable signal that derives its value from the provided stores and allows for custom adjustment and equality checks.\n","bindableDerived",{"source":7,"name":8},"## function_bindableProp\n> **bindableProp**\\\u003C`T`\\>(`store$`, `onChange$`, `adjustValue`?, `equal`?): [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T`\\>\n\nCreates a bindable property that synchronizes a writable signal with an optional adjustment function and equality check.\n\n### Type Parameters\n\n• **T**\n\nThe type of the value being stored.\n\n### Parameters\n\n• **store$**: [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `undefined` \\| `T`\\>\n\nThe writable signal that holds the current value.\n\n• **onChange$**: [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C(`newValue`) => `void`\\>\n\nA readable signal that triggers a callback when the value changes.\n\n• **adjustValue?** = `identity`\n\nAn optional function to adjust the value before storing it. Defaults to the identity function.\n\n• **equal?** = `tansuDefaultEqual`\n\nAn optional function to compare values for equality. Defaults to `tansuDefaultEqual`.\n\n### Returns\n\n[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T`\\>\n\nA writable signal that synchronizes with the provided store and triggers the onChange callback when updated.\n","bindableProp",{"source":10,"name":11},"## function_createPatch\n> **createPatch**\\\u003C`T`\\>(`stores`): (`storesValues`) => `void`\n\nUtility function designed to create a `patch` function related to the provided stores.\nAny key given to the patch function which is not in the original object will be ignored.\n\n### Type Parameters\n\n• **T** *extends* `object`\n\nThe type of the object that the stores represent.\n\n### Parameters\n\n• **stores**: [`ToWritableSignal`](#towritablesignal)\\\u003C`T`\\>\n\nThe stores to be updated.\n\n### Returns\n\n`Function`\n\n- A function that takes partial values of the stores and updates them.\n\n#### Parameters\n\n• **storesValues**: [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\>\n\n#### Returns\n\n`void`\n\n### Example\n\n```typescript\nconst storeA$ = writable(1);\nconst storeB$ = writable(1);\nconst patch = createPatch({a: storeA$, b: storeB$});\n\npatch({a: 2}) // will perform storeA$.set(2)\npatch({a: 2, b: 2}) // will perform storeA$.set(2) and storeB$.set(2) in the same batch.\npatch({a: 2, c: 2}) // will perform storeA$.set(2), c is ignored.\n\n```\n","createPatch",{"source":13,"name":14},"## function_findChangedProperties\n> **findChangedProperties**\\\u003C`T`\\>(`obj1`, `obj2`): [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\> \\| `null`\n\nThis utility function is designed to compare the first level of two objects.\n\nIt returns a new object which has all the keys for which the values in `obj1`\nand `obj2` are different, with the values from `obj2`, or null if objects\nare identical.\n\n### Type Parameters\n\n• **T** *extends* [`Record`](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)\\\u003C`string`, `any`\\>\n\nThe type of the objects being compared.\n\n### Parameters\n\n• **obj1**: [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\>\n\nThe first partial object to compare.\n\n• **obj2**: [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\>\n\nThe second partial object to compare.\n\n### Returns\n\n[`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\> \\| `null`\n\nA partial object containing the properties that have different values, or `null` if the objects are identical.\n","findChangedProperties",{"source":16,"name":17},"## function_isStore\n> **isStore**(`x`): `x is ReadableSignal\u003Cany>`\n\nReturns true if the provided argument is a store (ReadableSignal).\n\n### Parameters\n\n• **x**: `any`\n\nargument that is tested\n\n### Returns\n\n`x is ReadableSignal\u003Cany>`\n\ntrue if the argument is a store (ReadableSignal)\n","isStore",{"source":19,"name":20},"## function_mergeConfigStores\n> **mergeConfigStores**\\\u003C`T`\\>(`keys`, `config1`?, `config2`?): [`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\nMerges two configuration stores into one, prioritizing the first store's values\nwhen both stores have a value for the same key.\n\n### Type Parameters\n\n• **T** *extends* `object`\n\nThe type of the configuration object.\n\n### Parameters\n\n• **keys**: keyof `T`[]\n\nThe keys to merge from the configuration stores.\n\n• **config1?**: [`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\nThe first configuration store.\n\n• **config2?**: [`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\nThe second configuration store.\n\n### Returns\n\n[`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\n- The merged configuration store.\n","mergeConfigStores",{"source":22,"name":23},"## function_normalizeConfigStores\n> **normalizeConfigStores**\\\u003C`T`\\>(`keys`, `config`?): [`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\nNormalizes configuration stores by converting them into readable signals.\n\n### Type Parameters\n\n• **T** *extends* `object`\n\nThe type of the configuration object.\n\n### Parameters\n\n• **keys**: keyof `T`[]\n\nAn array of keys to normalize from the configuration object.\n\n• **config?**: [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C[`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\>\\> \\| [`ValuesOrReadableSignals`](../types#valuesorreadablesignals)\\\u003C`T`\\>\n\nThe configuration object or readable signals to normalize.\n\n### Returns\n\n[`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\nAn object containing readable signals for each key in the configuration.\n","normalizeConfigStores",{"source":25,"name":26},"## type alias_ReadableSignals\n> **ReadableSignals**\\\u003C`T`\\>: \\{ \\[K in keyof T\\]?: ReadableSignal\\\u003CT\\[K\\] \\| undefined\\> \\}\n\nRepresents a collection of readable signals for an object type `T`.\nEach key in the object corresponds to a key in `T`, and the value is an optional `ReadableSignal`\nthat can hold the value of the corresponding property in `T` or `undefined`.\n\n### Type Parameters\n\n• **T** *extends* `object`\n\nThe object type for which the readable signals are defined.\n","ReadableSignals",{"source":28,"name":29},"## function_stateStores\n> **stateStores**\\\u003C`A`\\>(`inputStores`): `object`\n\nUsing input stores, this function builds an object containing the stores as readable and a global state.\n\n### Type Parameters\n\n• **A** *extends* `object`\n\nThe type of the state object.\n\n### Parameters\n\n• **inputStores**: \\{ \\[K in string \\| number \\| symbol as \\`$\\{K & string\\}$\\`\\]: ReadableSignal\\\u003Cany\\> \\}\n\nthe input stores\n\n### Returns\n\n`object`\n\nthe object containing the stores as readable and the global state\n\n#### state$\n\n> **state$**: [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`A`\\>\n\n#### stores\n\n> **stores**: \\{ \\[K in string \\| number \\| symbol as \\`$\\{K & string\\}$\\`\\]: ReadableSignal\\\u003CA\\[K\\]\\> \\}\n","stateStores",{"source":31,"name":32},"## function_toAngularSignal\n> **toAngularSignal**\\\u003C`T`\\>(`tansuSignal`): [`Signal`](https://angular.dev/api/core/Signal)\\\u003C`T`\\>\n\nConverts a Tansu `ReadableSignal` to an Angular `Signal`.\n\nThis function wraps the provided Tansu signal in an Angular signal, ensuring that updates\nare properly handled within Angular's zone. It subscribes to the Tansu signal and updates\nthe Angular signal with the received values. The equality function for the Angular signal\nis set to always return false, ensuring that every new value from the Tansu signal triggers\nan update.\n\n### Type Parameters\n\n• **T**\n\nThe type of the value emitted by the signals.\n\n### Parameters\n\n• **tansuSignal**: [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`T`\\>\n\nThe Tansu signal to convert.\n\n### Returns\n\n[`Signal`](https://angular.dev/api/core/Signal)\\\u003C`T`\\>\n\n- The resulting Angular signal.\n","toAngularSignal",{"source":34,"name":35},"## function_toReadableStore\n> **toReadableStore**\\\u003C`T`\\>(`x`): [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`T`\\>\n\nIf the provided argument is already a store, it is returned as is, otherwise, a readable store is created with the provided argument as its initial value.\n\n### Type Parameters\n\n• **T**\n\nThe type of the value.\n\n### Parameters\n\n• **x**: `T` \\| [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`T`\\>\n\nThe value to be converted to a readable store.\n\n### Returns\n\n[`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`T`\\>\n\n- The readable store containing the value.\n","toReadableStore",{"source":37,"name":38},"## type alias_ToWritableSignal\n> **ToWritableSignal**\\\u003C`P`\\>: \\{ \\[K in keyof P as \\`$\\{K & string\\}$\\`\\]-?: WritableSignal\\\u003CP\\[K\\], P\\[K\\] \\| undefined\\> \\}\n\nTransforms the properties of a given type `P` into writable signals.\nEach property key in `P` is suffixed with a `$` and its type is converted to a `WritableSignal`.\n\n### Type Parameters\n\n• **P**\n\nThe original type whose properties are to be transformed.\n","ToWritableSignal",{"source":40,"name":41},"## function_toWritableStore\n> **toWritableStore**\\\u003C`T`\\>(`x`): [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T`\\>\n\nConverts a value or a writable signal into a writable signal.\n\n### Type Parameters\n\n• **T**\n\nThe type of the value or signal.\n\n### Parameters\n\n• **x**: `T` \\| [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T`\\>\n\nThe value or writable signal to convert.\n\n### Returns\n\n[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T`\\>\n\n- The resulting writable signal.\n","toWritableStore",{"source":43,"name":44},"## type alias_WithoutDollar\n> **WithoutDollar**\\\u003C`S`\\>: `S` *extends* \\`$\\{infer U\\}$\\` ? `U` : `never`\n\nA utility type that removes the trailing dollar sign (`$`) from a string type.\n\n### Type Parameters\n\n• **S** *extends* \\`$\\{string\\}$\\`\n\nA string type that ends with a dollar sign (`$`).\n","WithoutDollar",{"source":46,"name":47},"## function_writablesForProps\n> **writablesForProps**\\\u003C`T`\\>(`defConfig`, `propsConfig`?, `options`?): [[`ToWritableSignal`](#towritablesignal)\\\u003C`T`\\>, (`storesValues`) => `void`]\n\nShortcut for calling both [writablesWithDefault](#writableswithdefault) and [createPatch](#createpatch) in one call.\n\n### Type Parameters\n\n• **T** *extends* `object`\n\nThe type of the properties configuration object.\n\n### Parameters\n\n• **defConfig**: `T`\n\nobject containing, for each property, a default value to use in case `config` does not provide the suitable default\nvalue for that property\n\n• **propsConfig?**: [`PropsConfig`](../types#propsconfig)\\\u003C`T`\\>\n\neither a store of objects containing, for each property of `defConfig`, the default value or an object containing\nfor each property of `defConfig` either a store containing the default value or the default value itself\n\n• **options?**: \\{ \\[K in string \\| number \\| symbol\\]: undefined \\| WritableWithDefaultOptions\\\u003CT\\[K\\]\\> \\}\n\nobject containing, for each property of `defConfig`, an optional object with the following optional functions: normalizeValue and equal\n\n### Returns\n\n[[`ToWritableSignal`](#towritablesignal)\\\u003C`T`\\>, (`storesValues`) => `void`]\n\nan array with two items: the first one containing the writables (returned by [writablesWithDefault](#writableswithdefault)),\nand the second one containing the patch function (returned by [createPatch](#createpatch))\n\n### Examples\n\n```ts\nconst defConfig = {propA: 1};\nconst validation = {propA: {normalizeValue: value => +value}};\nconst config$ = writable({propA: 5});\nconst [{propA$}, patch] = writablesForProps(defConfig, config$, validation);\n```\n\n```ts\nconst defConfig = {propA: 1, propB: 2};\nconst validation = {propA: {normalizeValue: value => +value}};\nconst config = {propA: 5, propB: writable(3)};\nconst [{propA$, propB$}, patch] = writablesForProps(defConfig, config, validation);\n```\n","writablesForProps",{"source":49,"name":50},"## function_writablesWithDefault\n> **writablesWithDefault**\\\u003C`T`\\>(`defConfig`, `propsConfig`?, `options`?): [`ToWritableSignal`](#towritablesignal)\\\u003C`T`\\>\n\nReturns an object containing, for each property of `defConfig`, a corresponding writable with the normalization and default value logic\ndescribed in [writableWithDefault](#writablewithdefault). Keys in the returned object are the same as the ones present in `defConfig`,\nwith the exta `$` suffix (showing that they are stores).\n\n### Type Parameters\n\n• **T** *extends* `object`\n\nThe type of the default configuration object.\n\n### Parameters\n\n• **defConfig**: `T`\n\nobject containing, for each property, a default value to use in case `config$` does not provide the suitable default\nvalue for that property\n\n• **propsConfig?**: [`PropsConfig`](../types#propsconfig)\\\u003C`T`\\>\n\nobject defining the config and props\n\n• **options?**: [`ConfigValidator`](../types#configvalidator)\\\u003C`T`\\>\n\nobject containing, for each property of `defConfig`, an optional object with the following optional functions: normalizeValue and equal\n\n### Returns\n\n[`ToWritableSignal`](#towritablesignal)\\\u003C`T`\\>\n\nan object containing writables\n\n### Examples\n\n```ts\nconst defConfig = {propA: 1};\nconst validation = {propA: {normalizeValue: value => +value}};\nconst config = writable({propA: 5});\nconst {propA$} = writablesWithDefault(defConfig, {config}, validation);\n```\n\n```ts\nconst defConfig = {propA: 1, propB: 2};\nconst validation = {propA: {normalizeValue: value => +value}};\nconst config = {propA: 5, propB: writable(3)};\nconst {propA$, propB$} = writablesWithDefault(defConfig, {config}, validation);\n```\n","writablesWithDefault",{"source":52,"name":53},"## function_writableWithDefault\n> **writableWithDefault**\\\u003C`T`\\>(`defValue`, `config$`, `options`, `own$`): [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T` \\| `undefined`\\>\n\nReturns a writable store whose value is either its own value (when it is not undefined) or a default value\nthat comes either from the `config$` store (when it is not undefined) or from `defValue`.\nIf a normalizeValue function is passed in the options, it is called to normalize non-undefined values coming\neither from the `config$` store or from the `set` or `update` functions. If a value is invalid (i.e. normalizeValue\nreturns the `invalidValue` symbol), an error is logged on the console and it is either not set (if it comes from the\n`set` or `update` functions), or the `defValue` is used instead (if the invalid value comes from the `config$` store).\n\n### Type Parameters\n\n• **T**\n\nThe type of the value.\n\n### Parameters\n\n• **defValue**: `T`\n\nDefault value used when both the own value and the config$ value are undefined.\n\n• **config$**: [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`undefined` \\| `T`\\> = `...`\n\nStore containing the default value used when the own value is undefined\n\n• **options**: [`WritableWithDefaultOptions`](../types#writablewithdefaultoptions)\\\u003C`T`\\> = `{}`\n\nObject which can contain the following optional functions: normalizeValue and equal\n\n• **own$**: [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`undefined` \\| `T`, `undefined` \\| `T`\\> = `...`\n\nStore containing the own value\n\n### Returns\n\n[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T` \\| `undefined`\\>\n\na writable store with the extra default value and normalization logic described above\n","writableWithDefault","API stores","@agnos-ui/angular-headless"],"uses":{"params":["framework","type","slug"]}}]}
