var re=(t,e,s)=>{if(!e.has(t))throw TypeError("Cannot "+s)};var i=(t,e,s)=>(re(t,e,"read from private field"),s?s.call(t):e.get(t)),c=(t,e,s)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,s)},l=(t,e,s,n)=>(re(t,e,"write to private field"),n?n.call(t,s):e.set(t,s),s);var de=(t,e,s,n)=>({set _(r){l(t,e,r,s)},get _(){return i(t,e,n)}}),h=(t,e,s)=>(re(t,e,"access private method"),s);import{p as G}from"./stores.a522f210.js";const te=typeof Symbol=="function"&&Symbol.observable||"@@observable",ce=Symbol(),O=()=>{},X=()=>{};X.unsubscribe=X;const ie=(t,e)=>{const s=t?t[e]:null;return typeof s=="function"?s.bind(t):O},me=t=>({next:typeof t=="function"?t.bind(null):ie(t,"next"),pause:ie(t,"pause"),resume:ie(t,"resume"),_value:void 0,_valueIndex:0,_paused:!1}),Se=function(){return this},ae=t=>{if(!t)return X;if(t.unsubscribe===t)return t;const e=typeof t=="function"?()=>t():()=>t.unsubscribe();return e.unsubscribe=e,e},ue=new WeakSet,Oe=t=>{let e=t.subscribe;return ue.has(e)||(e=(...s)=>ae(t.subscribe(...s)),ue.add(e)),e},se=t=>{const e="subscribe"in t?t:t[te]();return Oe(e)},Ve=t=>{let e;return t(s=>e=s)(),e};function P(t,e){const s=se(t),n=Object.assign(()=>C(n),e,{subscribe:s,[te]:Se});return n}const v=Symbol(),ye=Symbol();let oe=!1;const j=new Set,Pe=1e3,le=t=>{if(t>Pe)throw new Error("reached maximum number of store changes in one shot")},N=t=>{const e=!oe;e&&(oe=!0);try{return t()}finally{if(e)try{const s=new Map;for(const n of j){const r=s.get(n)??0;le(r),s.set(n,r+1),j.delete(n),n[ye]()}}finally{j.clear(),oe=!1}}},we=t=>Ve(se(t));let V=we;const C=t=>V(t),be=t=>({[t]:!0,[t-1]:!1,0:!1});var x,z,I,E,R,M,W,B,ge,H,xe,A,K;class fe{constructor(e){c(this,B);c(this,H);c(this,A);c(this,x,new Set);c(this,z,null);c(this,I,!1);c(this,E,1);c(this,R,void 0);c(this,M,be(1));c(this,W,new WeakMap);l(this,R,e)}[ye](){const e=i(this,E);for(const s of[...i(this,x)]){if(i(this,I)||i(this,E)!==e)return;s._valueIndex!==0&&h(this,A,K).call(this,s)}}[v](){}equal(e,s){return!this.notEqual(e,s)}notEqual(e,s){return!Object.is(e,s)||e&&typeof e=="object"||typeof e=="function"}pauseSubscribers(){if(!i(this,I)){l(this,I,!0),j.delete(this);for(const e of[...i(this,x)])e._valueIndex===0||e._paused||(e._paused=!0,e.pause())}}resumeSubscribers(){i(this,I)&&(l(this,I,!1),N(()=>{j.add(this)}))}set(e){if(!this.equal(i(this,R),e)){const s=i(this,E)+1;l(this,E,s),l(this,R,e),l(this,M,be(s)),this.pauseSubscribers()}this.resumeSubscribers()}update(e){this.set(e(i(this,R)))}onUse(){}subscribe(e){const s=me(e),n=e==null?void 0:e[ce];if(n){const o=i(this,W).get(n);o&&(s._value=o._value,s._valueIndex=o._valueIndex)}i(this,x).add(s),N(()=>{i(this,x).size==1?h(this,B,ge).call(this):this[v]()}),h(this,A,K).call(this,s);const r=()=>{const o=i(this,x).delete(s);s.next=O,s.pause=O,s.resume=O,o&&(i(this,W).set(r,s),i(this,x).size===0&&h(this,H,xe).call(this))};return r[v]=()=>{this[v](),h(this,A,K).call(this,s)},r.unsubscribe=r,r}[te](){return this}}x=new WeakMap,z=new WeakMap,I=new WeakMap,E=new WeakMap,R=new WeakMap,M=new WeakMap,W=new WeakMap,B=new WeakSet,ge=function(){l(this,z,ae(this.onUse()))},H=new WeakSet,xe=function(){const e=i(this,z);e&&(l(this,z,null),e())},A=new WeakSet,K=function(e){const s=i(this,M),n=i(this,E),r=i(this,R);let o=s[e._valueIndex];o==null&&(o=this.equal(e._value,r),s[e._valueIndex]=o),e._valueIndex=n,o?!i(this,I)&&e._paused&&(e._paused=!1,e.resume()):(e._value=r,e._paused=!1,e.next(r))};function Le(t){const e=s=>(s!=null&&s[ce]||me(s).next(t),X);return ue.add(e),Object.assign(()=>t,{subscribe:e,[te]:Se})}class Ie extends fe{constructor(e){super(e)}set(e){super.set(e)}update(e){super.update(e)}}const ne=(t,e)=>{const{onUse:s,equal:n,notEqual:r}=e;return s&&(t.onUse=function(){const o=u=>this.set(u);return o.set=o,o.update=u=>this.update(u),s(o)}),n&&(t.equal=function(o,u){return n(o,u)}),r&&(t.notEqual=function(o,u){return r(o,u)}),t};function Ue(t,e={}){return typeof e=="function"&&(e={onUse:e}),e.onUse?P(ne(new Ie(t),e)):Le(t)}function _e(t,e={}){typeof e=="function"&&(e={onUse:e});const s=ne(new Ie(t),e);return P(s,{set:s.set.bind(s),update:s.update.bind(s)})}function ze(t){return t.length<=1}const Ae=t=>t();var T,Q,m;class pe extends fe{constructor(s,n){super(n);c(this,T,void 0);c(this,Q,void 0);c(this,m,0);const r=Array.isArray(s);l(this,T,r),l(this,Q,(r?[...s]:[s]).map(se))}resumeSubscribers(){i(this,m)||super.resumeSubscribers()}onUse(){let s=!1,n=0;const r=i(this,T),o=i(this,Q),u=new Array(o.length);let a=null;const b=()=>{const f=a;f&&(a=null,f())},w=(f=!1)=>{f&&(s=!0),s&&!i(this,m)&&(n&&(n=0,b(),a=ae(this.derive(r?u:u[0]))),this.resumeSubscribers())},d=o.map((f,g)=>{const _=qe=>{u[g]=qe,n|=1<<g,l(this,m,i(this,m)&~(1<<g)),w()};return _.next=_,_.pause=()=>{l(this,m,i(this,m)|1<<g),this.pauseSubscribers()},_.resume=()=>{l(this,m,i(this,m)&~(1<<g)),w()},f(_)}),S=(f,g)=>{var _;i(this,m)&1<<g&&((_=f[v])==null||_.call(f))};return this[v]=()=>{let f=0;for(;i(this,m)&&(le(++f),s=!1,d.forEach(S),!i(this,m));)w(!0)},w(!0),this[v](),()=>{this[v]=O,b(),d.forEach(Ae)}}}T=new WeakMap,Q=new WeakMap,m=new WeakMap;function Fe(t,e,s){typeof e=="function"&&(e={derive:e});const{derive:n,...r}=e,o=ze(n)?class extends pe{derive(u){this.set(n(u))}}:class extends pe{derive(u){const a=b=>this.set(b);return a.set=a,a.update=b=>this.update(b),n(u,a)}};return P(ne(new o(t,s),{...r,onUse:void 0}))}const Ce=t=>{const e=V;try{return V=we,t()}finally{V=e}},De=({unsubscribe:t})=>t(),je=({resubscribe:t})=>t();var F,U,$,p,J,Y,Ee,Z,Re,q,D,k,L,ee,$e;class Ne extends fe{constructor(){super(void 0);c(this,Y);c(this,Z);c(this,q);c(this,k);c(this,ee);c(this,F,!1);c(this,U,!1);c(this,$,0);c(this,p,new Map);c(this,J,s=>Ce(()=>h(this,Z,Re).call(this,s)))}resumeSubscribers(){h(this,k,L).call(this)||super.resumeSubscribers()}[v](){var n;if(i(this,F))throw new Error("recursive computed");let s=0;for(;h(this,k,L).call(this);){le(++s),l(this,U,!0);try{for(const[,{pending:r,unsubscribe:o}]of i(this,p))r&&((n=o[v])==null||n.call(o))}finally{l(this,U,!1)}if(h(this,k,L).call(this))break;h(this,q,D).call(this)}}onUse(){return h(this,q,D).call(this,!0),this[v](),()=>i(this,p).forEach(De)}}F=new WeakMap,U=new WeakMap,$=new WeakMap,p=new WeakMap,J=new WeakMap,Y=new WeakSet,Ee=function(s){const n={versionIndex:i(this,$),unsubscribe:O,resubscribe:O,pending:!1,usedValueIndex:0,value:void 0,valueIndex:0},r=o=>{n.value=o,n.valueIndex++,n.pending=!1,!i(this,U)&&!h(this,k,L).call(this)&&N(()=>h(this,q,D).call(this))};return r.next=r,r.pause=()=>{n.pending=!0,this.pauseSubscribers()},r.resume=()=>{n.pending=!1,!i(this,U)&&!h(this,k,L).call(this)&&N(()=>h(this,q,D).call(this))},n.resubscribe=()=>{n.unsubscribe=s(r),r[ce]=n.unsubscribe},n.resubscribe(),n},Z=new WeakSet,Re=function(s){var r,o;let n=i(this,p).get(s);return n?(n.versionIndex=i(this,$),(o=(r=n.unsubscribe)[v])==null||o.call(r)):(n=h(this,Y,Ee).call(this,se(s)),i(this,p).set(s,n)),n.usedValueIndex=n.valueIndex,n.value},q=new WeakSet,D=function(s=!1){l(this,F,!0),l(this,U,!0);try{if(i(this,$)>0&&(s&&i(this,p).forEach(je),!h(this,ee,$e).call(this))){this.resumeSubscribers();return}de(this,$)._++;const n=i(this,$),r=V;let o;try{V=i(this,J),o=this.compute()}finally{V=r}this.set(o);for(const[u,a]of i(this,p))a.versionIndex!==n&&(i(this,p).delete(u),a.unsubscribe())}finally{l(this,U,!1),l(this,F,!1)}},k=new WeakSet,L=function(){for(const[,{pending:s}]of i(this,p))if(s)return!0;return!1},ee=new WeakSet,$e=function(){for(const[,{valueIndex:s,usedValueIndex:n}]of i(this,p))if(s!=n)return!0;return!1};function y(t,e={}){const s=class extends Ne{compute(){return t()}};return P(ne(new s,{...e,onUse:void 0}))}const Me=()=>{},We=t=>t;function Te(t){return function(e){N(()=>{var s;for(const[n,r]of Object.entries(e??{}))(s=t[`${n}$`])==null||s.set(r)})}}const Qe=function(t){this.set(t(this()))},ve=Symbol();function Ge(t,e=Ue(void 0),s={},n=_e(void 0)){const{normalizeValue:r=We,equal:o=Object.is}=s,u=()=>t,a=(d,S=u)=>{const f=d===void 0?void 0:r(d);return f===ve?(console.error("Not using invalid value",d),S()):f===void 0?S():f},b=y(()=>a(e()),{equal:o}),w=y(()=>a(n(),b),{equal:o});return P(w,{set(d){if(d!==void 0){const S=r(d);if(S===ve){console.error("Not setting invalid value",d);return}d=S}n.set(d)},update:Qe})}const he=t=>!!(t&&typeof t=="function"&&"subscribe"in t),Ke=t=>he(t)?t:Ue(t),Xe=t=>he(t)?t:_e(t),Be=(t,e)=>{const s={};if(e){const n=he(e);for(const r of t)s[r]=n?y(()=>e()[r]):Ke(e[r])}return s},He=(t,e,s)=>{const n={},r=Object.keys(t),o=Be(r,e==null?void 0:e.config),u=e==null?void 0:e.props;for(const a of r){const b=u==null?void 0:u[a];n[`${a}$`]=Ge(t[a],o[a],s==null?void 0:s[a],Xe(b))}return n},Je=(t,e,s)=>{const n=He(t,e,s);return[n,Te(n)]},Ye={elements:[],options:void 0},Ze=t=>{const[{elements$:e,options$:s},n]=Je(Ye,t),r=Fe([e,s],([o,u],a)=>{if(o.length){const b=new Map,w=new IntersectionObserver(d=>{for(const S of d){const{target:f,isIntersecting:g}=S;g?b.set(f,S):b.delete(f)}a(b)},u);for(const d of o)w.observe(d);return()=>{w.disconnect()}}return Me},new Map);return{elements$:P(e),visibleElements$:P(r),patch:n}},et=y(()=>{const t=C(G);if(!t.route.id)throw new Error("Page error");return t.route.id.split("/").length-2}),ke=y(()=>{const t=et();return t?"../".repeat(t):"./"}),ot=y(()=>new URL(ke(),window.location.href).href),tt="https://amadeusitgroup.github.io/AgnosUI/latest/";y(()=>{const t=C(G).url.href,e=new URL(ke(),t).href;return t.replace(e,tt)});const ut=y(()=>C(G).params.framework??"angular"),st=/^\/\[framework\]\/components\/[^/]*\/([^/]*)/,ct=y(()=>{const t=st.exec(C(G).route.id||"");return(t==null?void 0:t[1])||"examples"}),nt=/^\/\[framework\]\//,at=y(()=>(C(G).route.id||"").replace(nt,"")),lt=Ze();export{ct as a,P as b,y as c,at as f,lt as i,Me as n,ot as p,Ue as r,ut as s,_e as w};
