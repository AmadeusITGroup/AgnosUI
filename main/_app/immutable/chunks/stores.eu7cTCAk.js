var re=(t,e,s)=>{if(!e.has(t))throw TypeError("Cannot "+s)};var r=(t,e,s)=>(re(t,e,"read from private field"),s?s.call(t):e.get(t)),l=(t,e,s)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,s)},c=(t,e,s,n)=>(re(t,e,"write to private field"),n?n.call(t,s):e.set(t,s),s);var be=(t,e,s,n)=>({set _(i){c(t,e,i,s)},get _(){return r(t,e,n)}}),h=(t,e,s)=>(re(t,e,"access private method"),s);import{p as B}from"./stores.IPIUz8TB.js";var pe;const se=typeof Symbol=="function"&&Symbol.observable||"@@observable",ae=Symbol(),k=()=>{},J=()=>{};J.unsubscribe=J;const oe=(t,e)=>{const s=t?t[e]:null;return typeof s=="function"?s.bind(t):k},ge=t=>({next:typeof t=="function"?t.bind(null):oe(t,"next"),pause:oe(t,"pause"),resume:oe(t,"resume"),_value:void 0,_valueIndex:0,_paused:!1}),we=function(){return this},le=t=>{if(!t)return J;if(t.unsubscribe===t)return t;const e=typeof t=="function"?()=>t():()=>t.unsubscribe();return e.unsubscribe=e,e},ce=new WeakSet,Fe=t=>{let e=t.subscribe;return ce.has(e)||(e=(...s)=>le(t.subscribe(...s)),ce.add(e)),e},ne=t=>{const e="subscribe"in t?t:t[se]();return Fe(e)},Ce=t=>{let e;return t(s=>e=s)(),e};function z(t,e){const s=ne(t),n=Object.assign(()=>A(n),e,{subscribe:s,[se]:we});return n}const me=function(t){this.set(t(Re(()=>A(this))))};function De(t,e){return z(t,typeof e=="function"?{set:e,update:me}:{...e,set:(e==null?void 0:e.set)??k,update:(e==null?void 0:e.update)??(e!=null&&e.set?me:k)})}const m=Symbol(),Ie=Symbol();let ue=!1;const Q=new Set,Ne=1e3,fe=t=>{if(t>Ne)throw new Error("reached maximum number of store changes in one shot")},G=t=>{const e=!ue;e&&(ue=!0);try{return t()}finally{if(e)try{const s=new Map;for(const n of Q){const i=s.get(n)??0;fe(i),s.set(n,i+1),Q.delete(n),n[Ie]()}}finally{Q.clear(),ue=!1}}},Ue=t=>Ce(ne(t));let C=Ue;const A=t=>C(t),ve=t=>({[t]:!0,[t-1]:!1,0:!1}),M=Symbol(),Ee=(t,e)=>Object.is(t,e)&&(!t||typeof t!="object")&&typeof t!="function";var g,L,w,_,q,j,N,O,_e,Y,$e,E,H;class he{constructor(e){l(this,O);l(this,Y);l(this,E);l(this,g,void 0);l(this,L,void 0);l(this,w,void 0);l(this,_,void 0);l(this,q,void 0);l(this,j,void 0);l(this,N,void 0);c(this,g,new Set),c(this,L,null),c(this,w,!1),c(this,_,1),c(this,j,ve(1)),c(this,N,new WeakMap),this[pe]=!1,c(this,q,e)}[(pe=M,Ie)](){const e=r(this,_);for(const s of[...r(this,g)]){if(r(this,w)||r(this,_)!==e)return;s._valueIndex!==0&&h(this,E,H).call(this,s)}}[m](){}equal(e,s){return!this.notEqual(e,s)}notEqual(e,s){return!Ee(e,s)}pauseSubscribers(){if(!r(this,w)){c(this,w,!0),Q.delete(this);for(const e of[...r(this,g)])e._valueIndex===0||e._paused||(e._paused=!0,e.pause())}}resumeSubscribers(){r(this,w)&&(c(this,w,!1),G(()=>{Q.add(this)}))}set(e){const s=this[M];if(s||!this.equal(r(this,q),e)){const n=r(this,_)+1;c(this,_,n),c(this,q,e),c(this,j,ve(n)),s&&delete r(this,j)[n-1],this.pauseSubscribers()}this.resumeSubscribers()}update(e){this.set(e(r(this,q)))}onUse(){}subscribe(e){const s=ge(e),n=e==null?void 0:e[ae];if(n){const o=r(this,N).get(n);o&&(s._value=o._value,s._valueIndex=o._valueIndex)}r(this,g).add(s),G(()=>{r(this,g).size==1?h(this,O,_e).call(this):this[m]()}),h(this,E,H).call(this,s);const i=()=>{const o=r(this,g).delete(s);s.next=k,s.pause=k,s.resume=k,o&&(r(this,N).set(i,s),r(this,g).size===0&&h(this,Y,$e).call(this))};return i[m]=()=>{this[m](),h(this,E,H).call(this,s)},i.unsubscribe=i,i}[se](){return this}}g=new WeakMap,L=new WeakMap,w=new WeakMap,_=new WeakMap,q=new WeakMap,j=new WeakMap,N=new WeakMap,O=new WeakSet,_e=function(){c(this,L,le(this.onUse()))},Y=new WeakSet,$e=function(){const e=r(this,L);e&&(c(this,L,null),e())},E=new WeakSet,H=function(e){const s=r(this,j),n=r(this,_),i=r(this,q);let o=s[e._valueIndex];o==null&&(o=!!this.equal(e._value,i),s[e._valueIndex]=o),e._valueIndex=n,o?!r(this,w)&&e._paused&&(e._paused=!1,e.resume()):(e._value=i,e._paused=!1,e.next(i))};function We(t){const e=s=>(s!=null&&s[ae]||ge(s).next(t),J);return ce.add(e),Object.assign(()=>t,{subscribe:e,[se]:we})}class ke extends he{constructor(e){super(e)}set(e){super.set(e)}update(e){super.update(e)}}const ie=(t,e)=>{const{onUse:s,equal:n,notEqual:i}=e;return s&&(t.onUse=function(){const o=u=>this.set(u);return o.set=o,o.update=u=>this.update(u),s(o)}),n&&(t.equal=function(o,u){return n(o,u)}),i&&(t.notEqual=function(o,u){return i(o,u)}),t};function xe(t,e={}){return typeof e=="function"&&(e={onUse:e}),e.onUse?z(ie(new ke(t),e)):We(t)}function qe(t,e={}){typeof e=="function"&&(e={onUse:e});const s=ie(new ke(t),e);return z(s,{set:s.set.bind(s),update:s.update.bind(s)})}function Me(t){return t.length<=1}const Te=t=>t();var K,X,v;class Se extends he{constructor(s,n){super(n);l(this,K,void 0);l(this,X,void 0);l(this,v,0);const i=Array.isArray(s);c(this,K,i),c(this,X,(i?[...s]:[s]).map(ne))}resumeSubscribers(){r(this,v)||super.resumeSubscribers()}onUse(){let s=!1,n=0;const i=r(this,K),o=r(this,X),u=new Array(o.length);let a=null;const b=()=>{const f=a;f&&(a=null,f())},I=(f=!1)=>{f&&(s=!0),s&&!r(this,v)&&(n&&(n=0,b(),a=le(this.derive(i?u:u[0]))),this.resumeSubscribers())},d=o.map((f,U)=>{const x=je=>{u[U]=je,n|=1<<U,c(this,v,r(this,v)&~(1<<U)),I()};return x.next=x,x.pause=()=>{c(this,v,r(this,v)|1<<U),this.pauseSubscribers()},x.resume=()=>{c(this,v,r(this,v)&~(1<<U)),I()},f(x)}),y=(f,U)=>{var x;r(this,v)&1<<U&&((x=f[m])==null||x.call(f))};return this[m]=()=>{let f=0;for(;r(this,v)&&(fe(++f),s=!1,d.forEach(y),!r(this,v));)I(!0)},I(!0),this[m](),()=>{this[m]=k,b(),d.forEach(Te)}}}K=new WeakMap,X=new WeakMap,v=new WeakMap;function Qe(t,e,s){typeof e=="function"&&(e={derive:e});const{derive:n,...i}=e,o=Me(n)?class extends Se{constructor(u,a){super(u,a),this[M]=!0}derive(u){this.set(n(u)),this[M]=!1}}:class extends Se{derive(u){const a=b=>this.set(b);return a.set=a,a.update=b=>this.update(b),n(u,a)}};return z(ie(new o(t,s),{...i,onUse:void 0}))}const Re=t=>{const e=C;try{return C=Ue,t()}finally{C=e}},Ge=({unsubscribe:t})=>t(),Ke=({resubscribe:t})=>t();var W,$,R,p,Z,P,Ve,ee,ze,F,T,V,D,te,Ae;class Xe extends he{constructor(){super(void 0);l(this,P);l(this,ee);l(this,F);l(this,V);l(this,te);l(this,W,!1);l(this,$,!1);l(this,R,0);l(this,p,new Map);l(this,Z,s=>Re(()=>h(this,ee,ze).call(this,s)));this[M]=!0}resumeSubscribers(){h(this,V,D).call(this)||super.resumeSubscribers()}[m](){var n;if(r(this,W))throw new Error("recursive computed");let s=0;for(;h(this,V,D).call(this);){fe(++s),c(this,$,!0);try{for(const[,{pending:i,unsubscribe:o}]of r(this,p))i&&((n=o[m])==null||n.call(o))}finally{c(this,$,!1)}if(h(this,V,D).call(this))break;h(this,F,T).call(this)}}onUse(){return h(this,F,T).call(this,!0),this[m](),()=>r(this,p).forEach(Ge)}}W=new WeakMap,$=new WeakMap,R=new WeakMap,p=new WeakMap,Z=new WeakMap,P=new WeakSet,Ve=function(s){const n={versionIndex:r(this,R),unsubscribe:k,resubscribe:k,pending:!1,usedValueIndex:0,value:void 0,valueIndex:0},i=o=>{n.value=o,n.valueIndex++,n.pending=!1,!r(this,$)&&!h(this,V,D).call(this)&&G(()=>h(this,F,T).call(this))};return i.next=i,i.pause=()=>{n.pending=!0,this.pauseSubscribers()},i.resume=()=>{n.pending=!1,!r(this,$)&&!h(this,V,D).call(this)&&G(()=>h(this,F,T).call(this))},n.resubscribe=()=>{n.unsubscribe=s(i),i[ae]=n.unsubscribe},n.resubscribe(),n},ee=new WeakSet,ze=function(s){var i,o;let n=r(this,p).get(s);return n?(n.versionIndex=r(this,R),(o=(i=n.unsubscribe)[m])==null||o.call(i)):(n=h(this,P,Ve).call(this,ne(s)),r(this,p).set(s,n)),n.usedValueIndex=n.valueIndex,n.value},F=new WeakSet,T=function(s=!1){c(this,W,!0),c(this,$,!0);try{if(r(this,R)>0&&(s&&r(this,p).forEach(Ke),!h(this,te,Ae).call(this))){this.resumeSubscribers();return}be(this,R)._++;const n=r(this,R),i=C;let o;try{C=r(this,Z),o=this.compute()}finally{C=i}this.set(o),this[M]=!1;for(const[u,a]of r(this,p))a.versionIndex!==n&&(r(this,p).delete(u),a.unsubscribe())}finally{c(this,$,!1),c(this,W,!1)}},V=new WeakSet,D=function(){for(const[,{pending:s}]of r(this,p))if(s)return!0;return!1},te=new WeakSet,Ae=function(){for(const[,{valueIndex:s,usedValueIndex:n}]of r(this,p))if(s!=n)return!0;return!1};function S(t,e={}){const s=class extends Xe{compute(){return t()}};return z(ie(new s,{...e,onUse:void 0}))}const Be=()=>{},He=t=>t,ye=Symbol();function Je(t){return function(e){G(()=>{var s;for(const[n,i]of Object.entries(e??{}))(s=t[`${n}$`])==null||s.set(i)})}}function Oe(t,e=xe(void 0),s={},n=qe(void 0)){const{normalizeValue:i=He,equal:o=Object.is}=s,u=()=>t,a=(d,y=u)=>{const f=d===void 0?void 0:i(d);return f===ye?(console.error("Not using invalid value",d),y()):f===void 0?y():f},b=S(()=>a(e()),{equal:o}),I=S(()=>a(n(),b),{equal:o});return De(I,d=>{if(d!==void 0){const y=i(d);if(y===ye){console.error("Not setting invalid value",d);return}d=y}n.set(d)})}const de=t=>!!(t&&typeof t=="function"&&"subscribe"in t),Ye=t=>de(t)?t:xe(t),Ze=t=>de(t)?t:qe(t),Pe=(t,e)=>{const s={};if(e){const n=de(e);for(const i of t)s[i]=n?S(()=>e()[i]):Ye(e[i])}return s},et=(t,e,s)=>{const n={},i=Object.keys(t),o=Pe(i,e==null?void 0:e.config),u=e==null?void 0:e.props;for(const a of i){const b=u==null?void 0:u[a];n[`${a}$`]=Oe(t[a],o[a],s==null?void 0:s[a],Ze(b))}return n},tt=(t,e,s)=>{const n=et(t,e,s);return[n,Je(n)]},lt=t=>{const e=[],s=[],n={};for(const i of Object.keys(t))if(i.endsWith("$")){const o=t[i];e.push(i.substring(0,i.length-1)),s.push(o),n[i]=z(o)}return{stores:n,state$:S(()=>{const i=s.map(A),o={};return e.forEach((u,a)=>{o[u]=i[a]}),o})}},st={elements:[],options:void 0},nt=t=>{const[{elements$:e,options$:s},n]=tt(st,t),i=Qe([e,s],([o,u],a)=>{if(o.length){const b=new Map,I=new IntersectionObserver(d=>{for(const y of d){const{target:f,isIntersecting:U}=y;U?b.set(f,y):b.delete(f)}a(b)},u);for(const d of o)I.observe(d);return()=>{I.disconnect()}}return Be},new Map);return{elements$:z(e),visibleElements$:z(i),patch:n}},it=S(()=>{const t=A(B);if(!t.route.id)throw new Error("Page error");return t.route.id.split("/").length-2+Object.values(t.params).reduce((e,s)=>e+s.split("/").length-1,0)}),Le=S(()=>{const t=it();return t?"../".repeat(t):"./"}),ft=S(()=>new URL(Le(),window.location.href).href),rt="https://amadeusitgroup.github.io/AgnosUI/latest/";S(()=>{const t=A(B).url.href,e=new URL(Le(),t).href;return t.replace(e,rt)});const ht=S(()=>A(B).params.framework??"angular"),ot=/^\/docs\/\[framework\]\/components\/[^/]*\/([^/]*)/,dt=S(()=>{const t=ot.exec(A(B).route.id||"");return(t==null?void 0:t[1])||"examples"}),ut=/\/docs\/[a-z]*\/(.*)$/,bt=S(()=>{var e;return((e=A(B).url.pathname.match(ut))==null?void 0:e[1])??"/"}),pt=nt();export{dt as a,z as b,S as c,G as d,Qe as e,Ee as f,tt as g,lt as h,pt as i,bt as j,it as k,Be as n,ft as p,xe as r,ht as s,qe as w};
