import{a1 as X,aw as Y,h as Z,m as nn,av as tn,$ as en,F as on}from"./runtime.CoJv2S2D.js";import{g as sn}from"./entry.CPbCxprt.js";import{I as rn,n as y,w as an,e as h,f as ln,g as k,h as un,i as cn,j as q}from"./stores.DSyyXX6q.js";import{a as dn,p as M,m as fn,d as pn,f as mn,g as bn,h as U,j as vn}from"./logo-typescript.CAYgqp-S.js";function wn(n){X(n,n.v+1)}function xn(n){let t,r=en(0),i=0,u=on;function f(){return Y()?(Z(r),nn(()=>{if(i===0){let c=!1;u=n.subscribe(p=>{t=p,c&&wn(r)}),c=!0}return i+=1,()=>{i-=1,tn().then(()=>{i===0&&u()})}}),t):sn(n)}return"set"in n?{get current(){return f()},set current(c){n.set(c)}}:{get current(){return f()}}}function W(n){return n===!0||n===!1}function hn(n){return typeof n=="function"}function yn(n){return typeof n=="string"}const $n=n=>t=>t===null||n(t);function gn(n){return t=>n.includes(t)}const $=n=>t=>n(t)?t:rn,O={normalizeValue:$(W)},Sn={normalizeValue:$($n(W))},Bn={normalizeValue:$(yn)},C={normalizeValue:$(hn),equal:Object.is};function Fn(n){return{normalizeValue:$(gn(n))}}const R=new Promise(y),Vn=(n,t)=>{n.style.display=t==="show"?"":"none"},Dn={animated:!0,animatedOnInit:!1,initDone:null,visible:!0,transition:Vn,onShown:y,onHidden:y,onVisibleChange:y},Cn={animated:O,animatedOnInit:O,visible:O,transition:C,onShown:C,onHidden:C,onVisibleChange:C,initDone:Sn},Hn=n=>{const[{animated$:t,initDone$:r,visible$:i,transition$:u,onShown$:f,onHidden$:c,onVisibleChange$:p,animatedOnInit$:g},b]=an(Dn,n,Cn),{element$:E,directive:G}=dn(),x=h(()=>!!E()),S=ln(p,[i],([e])=>e),v=k(null),A=h(()=>!!v()),B=()=>{let e;return v.update(o=>(o?.abort.abort(),e=o?.context,null)),e},J=(e,o,d,a)=>q(()=>{const V=new AbortController,l=V.signal,m=B()??{},{promise:w,resolve:P}=M(),D={abort:V,animated:o,visible:e,context:m,element:d,transitionFn:a,promise:w};return v.set(D),P((async()=>{var L;try{await a(d,e?"show":"hide",o,l,m)}finally{l.aborted?await R:(v.set(null),(L=(e?f:c)())==null||L())}})()),D}),K=h(()=>!A()&&S()&&x()),Q=h(()=>!A()&&!S()),F=h(()=>r()?t():g()),z=k(null);let H,N=i(),s=null;const _=un([S,E,F,z,u,v],([e,o,d,a,V,l])=>{const m=H!==o;H=o;const w=N!==e;if(N=e,o){r()==null&&r.set(!0);const P=a!=null&&l&&l.animated!=a;if(m||w||P){(w||a!=null)&&(s=null);const D=a??s?.animated??(m&&!e?!1:d);l=J(e,D,o,V),s?.resolve(l.promise),s=null}}else m&&(B(),l=null),(w||e&&s?.animated!==a)&&(s=e&&a!=null?{animated:a,...M()}:null);return s?.promise??l?.promise});let j={};const I=async(e=!i(),o=F())=>{const d={};j=d;try{await q(()=>{try{return z.set(o),i.set(e),_()}finally{z.set(null)}})}finally{j!==d&&await R}},T=fn(G,mn(e=>{e&&b(e)}),pn(_));return{...cn({visible$:S,element$:E,elementPresent$:x,transitioning$:A,shown$:K,hidden$:Q}),patch:b,directives:{directive:T},api:{show:I.bind(null,!0),hide:I.bind(null,!1),toggle:I}}};function En(n){return window.getComputedStyle(n).transitionProperty!=="none"}function An(n){const{transitionDelay:t,transitionDuration:r}=window.getComputedStyle(n),i=parseFloat(t),u=parseFloat(r);return(i+u)*1e3}const Nn=n=>async(t,r,i,u,f)=>{const c=n(t,r,i,f)??y;if(bn(t)&&i&&En(t)){const p=U(u,"abort"),g=U(t,"transitionend"),b=vn(An(t));await Promise.race([p.promise,g.promise,b.promise]),p.unsubscribe(),g.unsubscribe(),b.unsubscribe()}u.aborted||c()};export{Hn as a,C as b,Nn as c,Bn as d,Fn as e,xn as f,O as t};
