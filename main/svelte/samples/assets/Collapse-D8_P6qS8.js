import{p as fe,M as pe,d as ve,b as be,a as _e,t as me,L as Se,e as ge,l as we,g as xe,q as ye}from"./AppCommon-BEC3JAXJ.js";import{s as Ce}from"./snippet-yb0R4CT4.js";import{a as Ie}from"./actions-BN56Q8Vc.js";import{c as ke}from"./baseTransitions-BJRWd9iO.js";import{w as qe,s as We,m as Me,a as Ee}from"./directive-CKEccryv-C6Ed9ZXZ.js";import{t as U,a as N,b as X}from"./writables-DCiBdIBK-DqpCveAy.js";import{a as $e,c as Oe}from"./collapse-CVjUhnIz-Dx7qHoOC.js";import{c as Ve}from"./config-B4h43_FM.js";var j=e=>{throw TypeError(e)},Q=(e,t,s)=>t.has(e)||j("Cannot "+s),n=(e,t,s)=>(Q(e,t,"read from private field"),s?s.call(e):t.get(e)),c=(e,t,s)=>t.has(e)?j("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,s),r=(e,t,s,i)=>(Q(e,t,"write to private field"),t.set(e,s),s),l=(e,t,s)=>(Q(e,t,"access private method"),s),Ue=(e,t,s,i)=>({set _(a){r(e,t,a)},get _(){return n(e,t,i)}}),f,q,p,v,w,I,M,g,ee,te,P,$,_,x,d,G,u,se,ie,O,k,ne,J;const B=typeof Symbol=="function"&&Symbol.observable||"@@observable",ae=Symbol(),m=()=>{},D=()=>{};D.unsubscribe=D;const H=(e,t)=>{const s=e?e[t]:null;return typeof s=="function"?s.bind(e):m},Pe=e=>({next:typeof e=="function"?e.bind(null):H(e,"next"),pause:H(e,"pause"),resume:H(e,"resume"),_value:void 0,_valueIndex:0,_paused:!1}),ze=function(){return this},oe=e=>{if(!e)return D;if(e.unsubscribe===e)return e;const t=typeof e=="function"?()=>e():()=>e.unsubscribe();return t.unsubscribe=t,t},K=new WeakSet,Fe=e=>{let t=e.subscribe;return K.has(t)||(t=(...s)=>oe(e.subscribe(...s)),K.add(t)),t},L=e=>{const t="subscribe"in e?e:e[B]();return Fe(t)},Re=e=>{let t;return e(s=>t=s)(),t};function re(e,t){const s=L(e),i=Object.assign(()=>He(i),t,{subscribe:s,[B]:ze});return i}function Te(e,t){return re(e,{...t,set:m,update:m})}const b=Symbol(),le=Symbol();let A=!1;const E=new Set,Ne=1e3,ce=e=>{if(e>Ne)throw new Error("reached maximum number of store changes in one shot")},z=e=>{const t=!A;t&&(A=!0);try{return e()}finally{if(t)try{const s=new Map;for(const i of E){const a=s.get(i)??0;ce(a),s.set(i,a+1),E.delete(i),i[le]()}}finally{E.clear(),A=!1}}},ue=e=>Re(L(e));let y=ue;const He=e=>y(e),Y=e=>({[e]:!0,[e-1]:!1,0:!1}),F=Symbol(),Ae=(e,t)=>Object.is(e,t)&&(!e||typeof e!="object")&&typeof e!="function";class De{constructor(t){c(this,g),c(this,f),c(this,q),c(this,p),c(this,v),c(this,w),c(this,I),c(this,M),r(this,f,new Set),r(this,q,null),r(this,p,!1),r(this,v,1),r(this,I,Y(1)),r(this,M,new WeakMap),this[J]=!1,r(this,w,t)}[(J=F,le)](){const t=n(this,v);for(const s of[...n(this,f)]){if(n(this,p)||n(this,v)!==t)return;s._valueIndex!==0&&l(this,g,P).call(this,s)}}[b](){}equal(t,s){return!this.notEqual(t,s)}notEqual(t,s){return!Ae(t,s)}pauseSubscribers(){if(!n(this,p)){r(this,p,!0),E.delete(this);for(const t of[...n(this,f)])t._valueIndex===0||t._paused||(t._paused=!0,t.pause())}}resumeSubscribers(){n(this,p)&&(r(this,p,!1),z(()=>{E.add(this)}))}set(t){const s=this[F];if(s||!this.equal(n(this,w),t)){const i=n(this,v)+1;r(this,v,i),r(this,w,t),r(this,I,Y(i)),s&&delete n(this,I)[i-1],this.pauseSubscribers()}this.resumeSubscribers()}update(t){this.set(t(n(this,w)))}onUse(){}subscribe(t){const s=Pe(t),i=t==null?void 0:t[ae];if(i){const o=n(this,M).get(i);o&&(s._value=o._value,s._valueIndex=o._valueIndex)}n(this,f).add(s),z(()=>{n(this,f).size==1?l(this,g,ee).call(this):this[b]()}),l(this,g,P).call(this,s);const a=()=>{const o=n(this,f).delete(s);s.next=m,s.pause=m,s.resume=m,o&&(n(this,M).set(a,s),n(this,f).size===0&&l(this,g,te).call(this))};return a[b]=()=>{this[b](),l(this,g,P).call(this,s)},a.unsubscribe=a,a}[B](){return this}}f=new WeakMap;q=new WeakMap;p=new WeakMap;v=new WeakMap;w=new WeakMap;I=new WeakMap;M=new WeakMap;g=new WeakSet;ee=function(){r(this,q,oe(this.onUse()))};te=function(){const e=n(this,q);e&&(r(this,q,null),e())};P=function(e){const t=n(this,I),s=n(this,v),i=n(this,w);let a=t[e._valueIndex];a==null&&(a=!!this.equal(e._value,i),t[e._valueIndex]=a),e._valueIndex=s,a?!n(this,p)&&e._paused&&(e._paused=!1,e.resume()):(e._value=i,e._paused=!1,e.next(i))};const Qe=(e,t)=>{const{onUse:s,equal:i,notEqual:a}=t;return s&&(e.onUse=function(){const o=h=>this.set(h);return o.set=o,o.update=h=>this.update(h),s(o)}),i&&(e.equal=function(o,h){return i(o,h)}),a&&(e.notEqual=function(o,h){return a(o,h)}),e},Ge=e=>{const t=y;try{return y=ue,e()}finally{y=t}},Be=({unsubscribe:e})=>e(),Le=({resubscribe:e})=>e();class Xe extends De{constructor(){super(void 0),c(this,u),c(this,$,!1),c(this,_,!1),c(this,x,0),c(this,d,new Map),c(this,G,t=>Ge(()=>l(this,u,ie).call(this,t))),this[F]=!0}resumeSubscribers(){l(this,u,k).call(this)||super.resumeSubscribers()}[b](){var t;if(n(this,$))throw new Error("recursive computed");let s=0;for(;l(this,u,k).call(this);){ce(++s),r(this,_,!0);try{for(const[,{pending:i,unsubscribe:a}]of n(this,d))i&&((t=a[b])==null||t.call(a))}finally{r(this,_,!1)}if(l(this,u,k).call(this))break;l(this,u,O).call(this)}}onUse(){return l(this,u,O).call(this,!0),this[b](),()=>n(this,d).forEach(Be)}}$=new WeakMap;_=new WeakMap;x=new WeakMap;d=new WeakMap;G=new WeakMap;u=new WeakSet;se=function(e){const t={versionIndex:n(this,x),unsubscribe:m,resubscribe:m,pending:!1,usedValueIndex:0,value:void 0,valueIndex:0},s=i=>{t.value=i,t.valueIndex++,t.pending=!1,!n(this,_)&&!l(this,u,k).call(this)&&z(()=>l(this,u,O).call(this))};return s.next=s,s.pause=()=>{t.pending=!0,this.pauseSubscribers()},s.resume=()=>{t.pending=!1,!n(this,_)&&!l(this,u,k).call(this)&&z(()=>l(this,u,O).call(this))},t.resubscribe=()=>{t.unsubscribe=e(s),s[ae]=t.unsubscribe},t.resubscribe(),t};ie=function(e){var t,s;let i=n(this,d).get(e);return i?(i.versionIndex=n(this,x),(s=(t=i.unsubscribe)[b])==null||s.call(t)):(i=l(this,u,se).call(this,L(e)),n(this,d).set(e,i)),i.usedValueIndex=i.valueIndex,i.value};O=function(e=!1){r(this,$,!0),r(this,_,!0);try{if(n(this,x)>0&&(e&&n(this,d).forEach(Le),!l(this,u,ne).call(this))){this.resumeSubscribers();return}Ue(this,x)._++;const t=n(this,x),s=y;let i;try{y=n(this,G),i=this.compute()}finally{y=s}this.set(i),this[F]=!1;for(const[a,o]of n(this,d))o.versionIndex!==t&&(n(this,d).delete(a),o.unsubscribe())}finally{r(this,_,!1),r(this,$,!1)}};k=function(){for(const[,{pending:e}]of n(this,d))if(e)return!0;return!1};ne=function(){for(const[,{valueIndex:e,usedValueIndex:t}]of n(this,d))if(e!=t)return!0;return!1};function Z(e,t={}){const s=class extends Xe{compute(){return e()}};return re(Qe(new s,{...t,onUse:void 0}))}const Je={visible:!0,horizontal:!1,onVisibleChange:()=>{},onShown:()=>{},onHidden:()=>{},animated:!0,animatedOnInit:!1,className:"",id:""},Ke={horizontal:U,onVisibleChange:N,onHidden:N,onShown:N,animatedOnInit:U,animated:U,className:X,visible:U,id:X};function Ye(e){const[{animatedOnInit$:t,animated$:s,visible$:i,onVisibleChange$:a,onHidden$:o,onShown$:h,horizontal$:S,id$:R,...V},T]=qe(Je,e,Ke),W=Te(Z(()=>S()?$e:Oe)),C=ke({props:{transition:W,visible:i,animated:s,animatedOnInit:t,onVisibleChange:a,onHidden:o,onShown:h}}),he=C.stores.visible$,de=C.stores.hidden$;return{...We({...V,visible$:he,hidden$:de,horizontal$:S}),patch:T,api:{open:C.api.show,close:C.api.hide,toggle:C.api.toggle},directives:{collapseDirective:Me(C.directives.directive,Ee(()=>({attributes:{id:Z(()=>R()||void 0)}})))}}}const Ze=Ye;var je=me("<div><!></div>");function lt(e,t){fe(t,!0);let s=pe(t,"visible",15),i=Se(t,["$$slots","$$events","$$legacy","children","visible"]);const{directives:{collapseDirective:a},api:o}=Ve({factory:Ze,widgetName:"collapse",get props(){return{...i,visible:s()}},events:{onVisibleChange:W=>{s(W)}},enablePatchChanged:!0}),h=o;var S=je();const R=ye(()=>({}));let V;var T=ge(S);return Ce(T,()=>t.children),Ie(S,W=>a(W)),ve(()=>V=we(S,V,{...xe(R)})),be(e,S),_e({api:h})}export{lt as C};
