import{p as j,M as B,K as G,t as K,d as X,h as J,j as Y,c as Z,a as ee}from"./AppCommon-KjZHMAMw.js";import{s as se}from"./snippet-CJVZFYJd.js";import{a as te}from"./actions-CIpHBM8M.js";import{c as re}from"./baseTransitions-CgsmCdDu.js";import{w as ie,i as ne,s as oe,t as ae}from"./stores-Mpux7cdj.js";import{n as U,a as I,m as ue}from"./dom-gfxqXJpK-DP4sFo7c.js";import{t as R,a as m,b as x}from"./writables-DCiBdIBK-DK6wySzo.js";import{a as ce,c as le}from"./collapse-CVjUhnIz-yj8sHjRU.js";import{c as he}from"./config-BTIRu7Sr.js";const de=(t,e)=>Object.is(t,e)&&(!t||typeof t!="object")&&typeof t!="function",E=[];let L=!1;const fe=t=>{const e=!L;L=!0;let s=!0,r,i;try{r=t()}finally{if(e){for(;E.length>0;){const n=E.shift();try{n.notify()}catch(a){s&&(s=!1,i=a)}}L=!1}}if(s)return r;throw i},V=t=>{try{if(t.skipMarkDirty=!0,t.producer.updateValue(),t.producer.flags&16)throw new Error("assert failed: store still dirty after updating it")}finally{t.skipMarkDirty=!1}},h=()=>{},S=(t,e)=>{const s=t?t[e]:null;return typeof s=="function"?s.bind(t):h},D={next:h,pause:h,resume:h},pe=t=>({next:typeof t=="function"?t.bind(null):S(t,"next"),pause:S(t,"pause"),resume:S(t,"resume")});class be{constructor(e,s){this.dirtyCount=1,this.subscriber=pe(s),this.link=e.registerConsumer(e.newLink(this)),this.notify(!0)}unsubscribe(){this.subscriber!==D&&(this.subscriber=D,this.link.producer.unregisterConsumer(this.link))}markDirty(){this.dirtyCount++,E.push(this),this.dirtyCount===1&&this.subscriber.pause()}notify(e=!1){if(this.dirtyCount--,this.dirtyCount===0&&this.subscriber!==D){const s=this.link,r=s.producer;if(V(s),r.isLinkUpToDate(s)&&!e)this.subscriber.resume();else{const i=r.updateLink(s);this.subscriber.next(i)}}}}let l=null;const d=t=>{const e=l;return l=t,e},T=t=>{let e;const s=d(null);try{e=t()}finally{d(s)}return e};let f=!1;const g=()=>{if(f)throw new Error("Reading or writing a signal is forbidden during the notification phase.")};let v=0;class me{constructor(e){this.value=e,this.flags=0,this.version=0,this.equalFn=de,this.equalCache=null,this.consumerLinks=[]}newLink(e){return{version:-1,value:void 0,producer:this,indexInProducer:0,consumer:e,skipMarkDirty:!1}}isLinkUpToDate(e){if(e.version===this.version)return!0;if(e.version===this.version-1||e.version<0)return!1;let s=this.equalCache;s||(s={},this.equalCache=s);let r=s[e.version];return r===void 0&&(r=this.equal(e.value,this.value),s[e.version]=r),r}updateLink(e){return e.value=this.value,e.version=this.version,this.readValue()}registerConsumer(e){const s=this.consumerLinks,r=s.length;return e.indexInProducer=r,s[r]=e,e}unregisterConsumer(e){const s=this.consumerLinks,r=e.indexInProducer;if(s[r]!==e)throw new Error("assert failed: invalid indexInProducer");const i=s.pop();e===i?r===0&&this.checkUnused():(s[r]=i,i.indexInProducer=r)}checkUnused(){}updateValue(){}equal(e,s){const r=this.equalFn;return r(e,s)}increaseEpoch(){v++,this.markConsumersDirty()}set(e){g(),this.equal(this.value,e)||fe(()=>{this.value=e,this.version++,this.equalCache=null,this.increaseEpoch()})}update(e){this.set(e(this.value))}markConsumersDirty(){const e=f;f=!0;try{const s=this.consumerLinks;for(let r=0,i=s.length;r<i;r++){const n=s[r];n.skipMarkDirty||n.consumer.markDirty()}}finally{f=e}}get(){return g(),l?l.addProducer(this):this.readValue()}readValue(){return this.value}subscribe(e){g();const s=new be(this,e),r=()=>s.unsubscribe();return r.unsubscribe=r,r}}let p=null,y=!1;const ge=()=>{if(y)throw new Error("assert failed: recursive flushUnused call");y=!0;try{const t=p;if(t){p=null;for(let e=0,s=t.length;e<s;e++){const r=t[e];r.flags&=-5,r.checkUnused()}}}finally{y=!1}};class _ extends me{constructor(){super(...arguments),this.extraUsages=0}updateValue(){if(!(this.flags&2)){if(!this.extraUsages&&!this.consumerLinks.length)throw new Error("assert failed: untracked producer usage");this.flags|=2,T(()=>this.startUse())}}checkUnused(){const e=this.flags;e&2&&!this.extraUsages&&!this.consumerLinks.length&&(y||e&1?(this.flags&=-3,T(()=>this.endUse())):e&4||(this.flags|=4,p||(p=[],queueMicrotask(ge)),p.push(this)))}get(){if(g(),l)return l.addProducer(this);this.extraUsages++;try{if(this.updateValue(),this.flags&16)throw new Error("assert failed: store still dirty after updating it");return this.readValue()}finally{--this.extraUsages===0&&this.checkUnused()}}}const P=()=>{};P.unsubscribe=P;const ve=t=>{if(!t)return P;if(t.unsubscribe===t)return t;const e=typeof t=="function"?()=>t():()=>t.unsubscribe();return e.unsubscribe=e,e};class ye extends _{constructor(e){super(void 0),this.subscribable=e,this.subscriber=this.createSubscriber(),this.unsubscribe=null,this.flags=1}createSubscriber(){const e=s=>this.set(s);return e.next=e,e.pause=()=>{this.markConsumersDirty()},e}startUse(){this.unsubscribe=ve(this.subscribable.subscribe(this.subscriber))}endUse(){const e=this.unsubscribe;e&&(this.unsubscribe=null,e())}}const A=typeof Symbol=="function"&&Symbol.observable||"@@observable",ke=function(){return this},H=Symbol(),O=new WeakMap,Ce=t=>{const e=t[H];if(e)return e;let s=O.get(t);if(!s){let r=t;"subscribe"in r||(r=r[A]()),s=new ye(r),O.set(t,s)}return s},W=(t,e)=>{const s=t.get.bind(t);return e&&Object.assign(s,e),s.get=s,s.subscribe=t.subscribe.bind(t),s[A]=ke,s[H]=t,s},M=1e3,k=Symbol("UNSET"),C=Symbol("ERRORED"),F=t=>t===k||t===C;class we extends _{constructor(){super(...arguments),this.flags=16}equal(e,s){return F(e)||F(s)?!1:super.equal(e,s)}markDirty(){this.flags&16||(this.flags|=16,this.markConsumersDirty())}readValue(){const e=this.value;if(e===C)throw this.error;if(e===k)throw new Error("assert failed: computed value is not set");return e}updateValue(){if(this.flags&8)throw new Error("recursive computed");if(super.updateValue(),!(this.flags&16))return;this.flags|=8;const e=d(null);try{let s=0;do{do if(s++,this.flags&=-17,this.areProducersUpToDate())return;while(this.flags&16&&s<M);this.recompute()}while(this.flags&16&&s<M);this.flags&16&&(this.flags&=-17,this.error=new Error("reached maximum number of store changes in one shot"),this.set(C))}finally{d(e),this.flags&=-9}}}class Ue extends we{constructor(e){super(k),this.computeFn=e,this.producerIndex=0,this.producerLinks=[],this.epoch=-1}increaseEpoch(){}updateValue(){this.flags&2&&this.epoch===v||(super.updateValue(),this.epoch=v)}get(){return!l&&!f&&this.epoch===v&&(!(this.flags&1)||this.flags&2)?this.readValue():super.get()}addProducer(e){const s=this.producerLinks,r=this.producerIndex;let i=s[r];return(i==null?void 0:i.producer)!==e&&(i&&s.push(i),i=e.registerConsumer(e.newLink(this))),s[r]=i,this.producerIndex=r+1,V(i),e.flags&1&&(this.flags|=1),e.updateLink(i)}startUse(){const e=this.producerLinks;for(let s=0,r=e.length;s<r;s++){const i=e[s];i.producer.registerConsumer(i)}this.flags|=16}endUse(){const e=this.producerLinks;for(let s=0,r=e.length;s<r;s++){const i=e[s];i.producer.unregisterConsumer(i)}}areProducersUpToDate(){if(this.value===k)return!1;const e=this.producerLinks;for(let s=0,r=e.length;s<r;s++){const i=e[s],n=i.producer;if(V(i),!n.isLinkUpToDate(i))return!1}return!0}recompute(){let e;const s=d(this);try{this.producerIndex=0,this.flags&=-2;const n=this.computeFn;e=n(),this.error=null}catch(n){e=C,this.error=n}finally{d(s)}const r=this.producerLinks,i=this.producerIndex;if(i<r.length)for(let n=0,a=r.length-i;n<a;n++){const o=r.pop();o.producer.unregisterConsumer(o)}this.set(e)}}function xe(t,e){return W(Ce(t),e)}function Le(t,e){return xe(t,{...e,set:h,update:h})}const Se=(t,e)=>t;function N(t,e){return W(Se(new Ue(t)))}const De={visible:!0,horizontal:!1,onVisibleChange:U,onShown:U,onHidden:U,animated:!0,animatedOnInit:!1,className:"",id:""},Ee={horizontal:m,onVisibleChange:x,onHidden:x,onShown:x,animatedOnInit:m,animated:m,className:R,visible:m,id:R};function Ve(t){const[{animatedOnInit$:e,animated$:s,visible$:r,onVisibleChange$:i,onHidden$:n,onShown$:a,horizontal$:o,id$:b,...w},u]=ie(De,t,Ee),$=ne(b),z=Le(N(()=>o()?ce:le)),c=re({props:{transition:z,visible:r,animated:s,animatedOnInit:e,onVisibleChange:i,onHidden:n,onShown:a}}),q=c.stores.visible$,Q=c.stores.hidden$;return{...oe({...w,visible$:q,hidden$:Q,horizontal$:o}),patch:u,api:{open:c.api.show,close:c.api.hide,toggle:c.api.toggle},directives:{collapseDirective:ue(c.directives.directive,I(()=>({attributes:{id:$},classNames:{"au-collapse":ae}}))),triggerDirective:I(()=>({attributes:{"aria-expanded":N(()=>`${q()}`),"aria-controls":$},events:{click:()=>c.api.toggle()}}))}}}const Pe=Ve;var $e=K("<div><!></div>");function Ae(t,e){j(e,!0);let s=B(e,"visible",15),r=G(e,["$$slots","$$events","$$legacy","children","visible"]);const{directives:{collapseDirective:i},api:n}=he({factory:Pe,widgetName:"collapse",get props(){return{...r,visible:s()}},events:{onVisibleChange:u=>{s(u)}},enablePatchChanged:!0}),a=n;var o=$e();let b;var w=X(o);return se(w,()=>e.children),te(o,u=>i==null?void 0:i(u)),J(u=>b=Y(o,b,{...u}),[()=>({})]),Z(t,o),ee({api:a})}export{Ae as C};
