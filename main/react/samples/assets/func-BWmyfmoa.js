var ee=(t,e,s)=>{if(!e.has(t))throw TypeError("Cannot "+s)};var i=(t,e,s)=>(ee(t,e,"read from private field"),s?s.call(t):e.get(t)),c=(t,e,s)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,s)},o=(t,e,s,n)=>(ee(t,e,"write to private field"),n?n.call(t,s):e.set(t,s),s);var ae=(t,e,s,n)=>({set _(u){o(t,e,u,s)},get _(){return i(t,e,n)}}),l=(t,e,s)=>(ee(t,e,"access private method"),s);var le;const Z=typeof Symbol=="function"&&Symbol.observable||"@@observable",ie=Symbol(),g=()=>{},$=()=>{};$.unsubscribe=$;const te=(t,e)=>{const s=t?t[e]:null;return typeof s=="function"?s.bind(t):g},be=t=>({next:typeof t=="function"?t.bind(null):te(t,"next"),pause:te(t,"pause"),resume:te(t,"resume"),_value:void 0,_valueIndex:0,_paused:!1}),pe=function(){return this},ue=t=>{if(!t)return $;if(t.unsubscribe===t)return t;const e=typeof t=="function"?()=>t():()=>t.unsubscribe();return e.unsubscribe=e,e},ne=new WeakSet,ke=t=>{let e=t.subscribe;return ne.has(e)||(e=(...s)=>ue(t.subscribe(...s)),ne.add(e)),e},O=t=>{const e="subscribe"in t?t:t[Z]();return ke(e)},Fe=t=>{let e;return t(s=>e=s)(),e};function T(t,e){const s=O(t),n=Object.assign(()=>me(n),e,{subscribe:s,[Z]:pe});return n}const he=function(t){this.set(t(_e(()=>me(this))))};function Qe(t,e){return T(t,typeof e=="function"?{set:e,update:he}:{...e,set:(e==null?void 0:e.set)??g,update:(e==null?void 0:e.update)??(e!=null&&e.set?he:g)})}const b=Symbol(),ve=Symbol();let se=!1;const W=new Set,Ae=1e3,re=t=>{if(t>Ae)throw new Error("reached maximum number of store changes in one shot")},B=t=>{const e=!se;e&&(se=!0);try{return t()}finally{if(e)try{const s=new Map;for(const n of W){const u=s.get(n)??0;re(u),s.set(n,u+1),W.delete(n),n[ve]()}}finally{W.clear(),se=!1}}},Se=t=>Fe(O(t));let F=Se;const me=t=>F(t),fe=t=>({[t]:!0,[t-1]:!1,0:!1}),D=Symbol(),Re=(t,e)=>Object.is(t,e)&&(!t||typeof t!="object")&&typeof t!="function";var v,q,S,m,_,C,z,E,ye,H,ge,V,X;class oe{constructor(e){c(this,E);c(this,H);c(this,V);c(this,v,void 0);c(this,q,void 0);c(this,S,void 0);c(this,m,void 0);c(this,_,void 0);c(this,C,void 0);c(this,z,void 0);o(this,v,new Set),o(this,q,null),o(this,S,!1),o(this,m,1),o(this,C,fe(1)),o(this,z,new WeakMap),this[le]=!1,o(this,_,e)}[(le=D,ve)](){const e=i(this,m);for(const s of[...i(this,v)]){if(i(this,S)||i(this,m)!==e)return;s._valueIndex!==0&&l(this,V,X).call(this,s)}}[b](){}equal(e,s){return!this.notEqual(e,s)}notEqual(e,s){return!Re(e,s)}pauseSubscribers(){if(!i(this,S)){o(this,S,!0),W.delete(this);for(const e of[...i(this,v)])e._valueIndex===0||e._paused||(e._paused=!0,e.pause())}}resumeSubscribers(){i(this,S)&&(o(this,S,!1),B(()=>{W.add(this)}))}set(e){const s=this[D];if(s||!this.equal(i(this,_),e)){const n=i(this,m)+1;o(this,m,n),o(this,_,e),o(this,C,fe(n)),s&&delete i(this,C)[n-1],this.pauseSubscribers()}this.resumeSubscribers()}update(e){this.set(e(i(this,_)))}onUse(){}subscribe(e){const s=be(e),n=e==null?void 0:e[ie];if(n){const r=i(this,z).get(n);r&&(s._value=r._value,s._valueIndex=r._valueIndex)}i(this,v).add(s),B(()=>{i(this,v).size==1?l(this,E,ye).call(this):this[b]()}),l(this,V,X).call(this,s);const u=()=>{const r=i(this,v).delete(s);s.next=g,s.pause=g,s.resume=g,r&&(i(this,z).set(u,s),i(this,v).size===0&&l(this,H,ge).call(this))};return u[b]=()=>{this[b](),l(this,V,X).call(this,s)},u.unsubscribe=u,u}[Z](){return this}}v=new WeakMap,q=new WeakMap,S=new WeakMap,m=new WeakMap,_=new WeakMap,C=new WeakMap,z=new WeakMap,E=new WeakSet,ye=function(){o(this,q,ue(this.onUse()))},H=new WeakSet,ge=function(){const e=i(this,q);e&&(o(this,q,null),e())},V=new WeakSet,X=function(e){const s=i(this,C),n=i(this,m),u=i(this,_);let r=s[e._valueIndex];r==null&&(r=!!this.equal(e._value,u),s[e._valueIndex]=r),e._valueIndex=n,r?!i(this,S)&&e._paused&&(e._paused=!1,e.resume()):(e._value=u,e._paused=!1,e.next(u))};function ze(t){const e=s=>(s!=null&&s[ie]||be(s).next(t),$);return ne.add(e),Object.assign(()=>t,{subscribe:e,[Z]:pe})}class Ie extends oe{constructor(e){super(e)}set(e){super.set(e)}update(e){super.update(e)}}const P=(t,e)=>{const{onUse:s,equal:n,notEqual:u}=e;return s&&(t.onUse=function(){const r=a=>this.set(a);return r.set=r,r.update=a=>this.update(a),s(r)}),n&&(t.equal=function(r,a){return n(r,a)}),u&&(t.notEqual=function(r,a){return u(r,a)}),t};function Te(t,e={}){return typeof e=="function"&&(e={onUse:e}),e.onUse?T(P(new Ie(t),e)):ze(t)}function Ge(t,e={}){typeof e=="function"&&(e={onUse:e});const s=P(new Ie(t),e);return T(s,{set:s.set.bind(s),update:s.update.bind(s)})}function Ve(t){return t.length<=1}const je=t=>t();var N,Q,p;class de extends oe{constructor(s,n){super(n);c(this,N,void 0);c(this,Q,void 0);c(this,p,0);const u=Array.isArray(s);o(this,N,u),o(this,Q,(u?[...s]:[s]).map(O))}resumeSubscribers(){i(this,p)||super.resumeSubscribers()}onUse(){let s=!1,n=0;const u=i(this,N),r=i(this,Q),a=new Array(r.length);let h=null;const A=()=>{const f=h;f&&(h=null,f())},G=(f=!1)=>{f&&(s=!0),s&&!i(this,p)&&(n&&(n=0,A(),h=ue(this.derive(u?a:a[0]))),this.resumeSubscribers())},ce=r.map((f,U)=>{const I=Ce=>{a[U]=Ce,n|=1<<U,o(this,p,i(this,p)&~(1<<U)),G()};return I.next=I,I.pause=()=>{o(this,p,i(this,p)|1<<U),this.pauseSubscribers()},I.resume=()=>{o(this,p,i(this,p)&~(1<<U)),G()},f(I)}),qe=(f,U)=>{var I;i(this,p)&1<<U&&((I=f[b])==null||I.call(f))};return this[b]=()=>{let f=0;for(;i(this,p)&&(re(++f),s=!1,ce.forEach(qe),!i(this,p));)G(!0)},G(!0),this[b](),()=>{this[b]=g,A(),ce.forEach(je)}}}N=new WeakMap,Q=new WeakMap,p=new WeakMap;function Xe(t,e,s){typeof e=="function"&&(e={derive:e});const{derive:n,...u}=e,r=Ve(n)?class extends de{constructor(a,h){super(a,h),this[D]=!0}derive(a){this.set(n(a)),this[D]=!1}}:class extends de{derive(a){const h=A=>this.set(A);return h.set=h,h.update=A=>this.update(A),n(a,h)}};return T(P(new r(t,s),{...u,onUse:void 0}))}const _e=t=>{const e=F;try{return F=Se,t()}finally{F=e}},De=({unsubscribe:t})=>t(),Me=({resubscribe:t})=>t();var j,y,x,d,J,K,xe,L,we,k,M,w,R,Y,Ue;class We extends oe{constructor(){super(void 0);c(this,K);c(this,L);c(this,k);c(this,w);c(this,Y);c(this,j,!1);c(this,y,!1);c(this,x,0);c(this,d,new Map);c(this,J,s=>_e(()=>l(this,L,we).call(this,s)));this[D]=!0}resumeSubscribers(){l(this,w,R).call(this)||super.resumeSubscribers()}[b](){var n;if(i(this,j))throw new Error("recursive computed");let s=0;for(;l(this,w,R).call(this);){re(++s),o(this,y,!0);try{for(const[,{pending:u,unsubscribe:r}]of i(this,d))u&&((n=r[b])==null||n.call(r))}finally{o(this,y,!1)}if(l(this,w,R).call(this))break;l(this,k,M).call(this)}}onUse(){return l(this,k,M).call(this,!0),this[b](),()=>i(this,d).forEach(De)}}j=new WeakMap,y=new WeakMap,x=new WeakMap,d=new WeakMap,J=new WeakMap,K=new WeakSet,xe=function(s){const n={versionIndex:i(this,x),unsubscribe:g,resubscribe:g,pending:!1,usedValueIndex:0,value:void 0,valueIndex:0},u=r=>{n.value=r,n.valueIndex++,n.pending=!1,!i(this,y)&&!l(this,w,R).call(this)&&B(()=>l(this,k,M).call(this))};return u.next=u,u.pause=()=>{n.pending=!0,this.pauseSubscribers()},u.resume=()=>{n.pending=!1,!i(this,y)&&!l(this,w,R).call(this)&&B(()=>l(this,k,M).call(this))},n.resubscribe=()=>{n.unsubscribe=s(u),u[ie]=n.unsubscribe},n.resubscribe(),n},L=new WeakSet,we=function(s){var u,r;let n=i(this,d).get(s);return n?(n.versionIndex=i(this,x),(r=(u=n.unsubscribe)[b])==null||r.call(u)):(n=l(this,K,xe).call(this,O(s)),i(this,d).set(s,n)),n.usedValueIndex=n.valueIndex,n.value},k=new WeakSet,M=function(s=!1){o(this,j,!0),o(this,y,!0);try{if(i(this,x)>0&&(s&&i(this,d).forEach(Me),!l(this,Y,Ue).call(this))){this.resumeSubscribers();return}ae(this,x)._++;const n=i(this,x),u=F;let r;try{F=i(this,J),r=this.compute()}finally{F=u}this.set(r),this[D]=!1;for(const[a,h]of i(this,d))h.versionIndex!==n&&(i(this,d).delete(a),h.unsubscribe())}finally{o(this,y,!1),o(this,j,!1)}},w=new WeakSet,R=function(){for(const[,{pending:s}]of i(this,d))if(s)return!0;return!1},Y=new WeakSet,Ue=function(){for(const[,{valueIndex:s,usedValueIndex:n}]of i(this,d))if(s!=n)return!0;return!1};function $e(t,e={}){const s=class extends We{compute(){return t()}};return T(P(new s,{...e,onUse:void 0}))}const Be=()=>{},Ee=t=>t;export{T as a,B as b,$e as c,Qe as d,Re as e,Xe as f,me as g,Ee as i,Be as n,Te as r,Ge as w};
