import{r as D,j as ue}from"./App-DI9ur9y5.js";import{u as ce}from"./config-BcuXC-aU.js";import{c as he}from"./baseTransitions-DdKg17TT.js";import{w as fe,s as de,b as pe}from"./directive-CKEccryv-9fW5PEkg.js";import{t as ve}from"./writables-DoU_XYTX-WNj2ILfP.js";import{a as be,c as _e}from"./collapse-CVjUhnIz-C9N8JR4a.js";import{a as me}from"./directive-DNXkB1Wc-DMhW1hGh.js";var j=e=>{throw TypeError(e)},R=(e,t,s)=>t.has(e)||j("Cannot "+s),n=(e,t,s)=>(R(e,t,"read from private field"),s?s.call(e):t.get(e)),u=(e,t,s)=>t.has(e)?j("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,s),o=(e,t,s,i)=>(R(e,t,"write to private field"),t.set(e,s),s),l=(e,t,s)=>(R(e,t,"access private method"),s),Se=(e,t,s,i)=>({set _(a){o(e,t,a)},get _(){return n(e,t,i)}}),d,k,p,v,x,y,W,S,B,X,$,E,_,w,h,T,c,J,K,M,I,L,A;const F=typeof Symbol=="function"&&Symbol.observable||"@@observable",Y=Symbol(),m=()=>{},P=()=>{};P.unsubscribe=P;const V=(e,t)=>{const s=e?e[t]:null;return typeof s=="function"?s.bind(e):m},xe=e=>({next:typeof e=="function"?e.bind(null):V(e,"next"),pause:V(e,"pause"),resume:V(e,"resume"),_value:void 0,_valueIndex:0,_paused:!1}),we=function(){return this},Z=e=>{if(!e)return P;if(e.unsubscribe===e)return e;const t=typeof e=="function"?()=>e():()=>e.unsubscribe();return t.unsubscribe=t,t},Q=new WeakSet,ge=e=>{let t=e.subscribe;return Q.has(t)||(t=(...s)=>Z(e.subscribe(...s)),Q.add(t)),t},H=e=>{const t="subscribe"in e?e:e[F]();return ge(t)},Ce=e=>{let t;return e(s=>t=s)(),t};function ee(e,t){const s=H(e),i=Object.assign(()=>ke(i),t,{subscribe:s,[F]:we});return i}function ye(e,t){return ee(e,{...t,set:m,update:m})}const b=Symbol(),te=Symbol();let z=!1;const q=new Set,Ie=1e3,se=e=>{if(e>Ie)throw new Error("reached maximum number of store changes in one shot")},O=e=>{const t=!z;t&&(z=!0);try{return e()}finally{if(t)try{const s=new Map;for(const i of q){const a=s.get(i)??0;se(a),s.set(i,a+1),q.delete(i),i[te]()}}finally{q.clear(),z=!1}}},ie=e=>Ce(H(e));let g=ie;const ke=e=>g(e),G=e=>({[e]:!0,[e-1]:!1,0:!1}),U=Symbol(),We=(e,t)=>Object.is(e,t)&&(!e||typeof e!="object")&&typeof e!="function";class qe{constructor(t){u(this,S),u(this,d),u(this,k),u(this,p),u(this,v),u(this,x),u(this,y),u(this,W),o(this,d,new Set),o(this,k,null),o(this,p,!1),o(this,v,1),o(this,y,G(1)),o(this,W,new WeakMap),this[A]=!1,o(this,x,t)}[(A=U,te)](){const t=n(this,v);for(const s of[...n(this,d)]){if(n(this,p)||n(this,v)!==t)return;s._valueIndex!==0&&l(this,S,$).call(this,s)}}[b](){}equal(t,s){return!this.notEqual(t,s)}notEqual(t,s){return!We(t,s)}pauseSubscribers(){if(!n(this,p)){o(this,p,!0),q.delete(this);for(const t of[...n(this,d)])t._valueIndex===0||t._paused||(t._paused=!0,t.pause())}}resumeSubscribers(){n(this,p)&&(o(this,p,!1),O(()=>{q.add(this)}))}set(t){const s=this[U];if(s||!this.equal(n(this,x),t)){const i=n(this,v)+1;o(this,v,i),o(this,x,t),o(this,y,G(i)),s&&delete n(this,y)[i-1],this.pauseSubscribers()}this.resumeSubscribers()}update(t){this.set(t(n(this,x)))}onUse(){}subscribe(t){const s=xe(t),i=t==null?void 0:t[Y];if(i){const r=n(this,W).get(i);r&&(s._value=r._value,s._valueIndex=r._valueIndex)}n(this,d).add(s),O(()=>{n(this,d).size==1?l(this,S,B).call(this):this[b]()}),l(this,S,$).call(this,s);const a=()=>{const r=n(this,d).delete(s);s.next=m,s.pause=m,s.resume=m,r&&(n(this,W).set(a,s),n(this,d).size===0&&l(this,S,X).call(this))};return a[b]=()=>{this[b](),l(this,S,$).call(this,s)},a.unsubscribe=a,a}[F](){return this}}d=new WeakMap;k=new WeakMap;p=new WeakMap;v=new WeakMap;x=new WeakMap;y=new WeakMap;W=new WeakMap;S=new WeakSet;B=function(){o(this,k,Z(this.onUse()))};X=function(){const e=n(this,k);e&&(o(this,k,null),e())};$=function(e){const t=n(this,y),s=n(this,v),i=n(this,x);let a=t[e._valueIndex];a==null&&(a=!!this.equal(e._value,i),t[e._valueIndex]=a),e._valueIndex=s,a?!n(this,p)&&e._paused&&(e._paused=!1,e.resume()):(e._value=i,e._paused=!1,e.next(i))};const Ee=(e,t)=>{const{onUse:s,equal:i,notEqual:a}=t;return s&&(e.onUse=function(){const r=f=>this.set(f);return r.set=r,r.update=f=>this.update(f),s(r)}),i&&(e.equal=function(r,f){return i(r,f)}),a&&(e.notEqual=function(r,f){return a(r,f)}),e},Me=e=>{const t=g;try{return g=ie,e()}finally{g=t}},$e=({unsubscribe:e})=>e(),Oe=({resubscribe:e})=>e();class Ue extends qe{constructor(){super(void 0),u(this,c),u(this,E,!1),u(this,_,!1),u(this,w,0),u(this,h,new Map),u(this,T,t=>Me(()=>l(this,c,K).call(this,t))),this[U]=!0}resumeSubscribers(){l(this,c,I).call(this)||super.resumeSubscribers()}[b](){var t;if(n(this,E))throw new Error("recursive computed");let s=0;for(;l(this,c,I).call(this);){se(++s),o(this,_,!0);try{for(const[,{pending:i,unsubscribe:a}]of n(this,h))i&&((t=a[b])==null||t.call(a))}finally{o(this,_,!1)}if(l(this,c,I).call(this))break;l(this,c,M).call(this)}}onUse(){return l(this,c,M).call(this,!0),this[b](),()=>n(this,h).forEach($e)}}E=new WeakMap;_=new WeakMap;w=new WeakMap;h=new WeakMap;T=new WeakMap;c=new WeakSet;J=function(e){const t={versionIndex:n(this,w),unsubscribe:m,resubscribe:m,pending:!1,usedValueIndex:0,value:void 0,valueIndex:0},s=i=>{t.value=i,t.valueIndex++,t.pending=!1,!n(this,_)&&!l(this,c,I).call(this)&&O(()=>l(this,c,M).call(this))};return s.next=s,s.pause=()=>{t.pending=!0,this.pauseSubscribers()},s.resume=()=>{t.pending=!1,!n(this,_)&&!l(this,c,I).call(this)&&O(()=>l(this,c,M).call(this))},t.resubscribe=()=>{t.unsubscribe=e(s),s[Y]=t.unsubscribe},t.resubscribe(),t};K=function(e){var t,s;let i=n(this,h).get(e);return i?(i.versionIndex=n(this,w),(s=(t=i.unsubscribe)[b])==null||s.call(t)):(i=l(this,c,J).call(this,H(e)),n(this,h).set(e,i)),i.usedValueIndex=i.valueIndex,i.value};M=function(e=!1){o(this,E,!0),o(this,_,!0);try{if(n(this,w)>0&&(e&&n(this,h).forEach(Oe),!l(this,c,L).call(this))){this.resumeSubscribers();return}Se(this,w)._++;const t=n(this,w),s=g;let i;try{g=n(this,T),i=this.compute()}finally{g=s}this.set(i),this[U]=!1;for(const[a,r]of n(this,h))r.versionIndex!==t&&(n(this,h).delete(a),r.unsubscribe())}finally{o(this,_,!1),o(this,E,!1)}};I=function(){for(const[,{pending:e}]of n(this,h))if(e)return!0;return!1};L=function(){for(const[,{valueIndex:e,usedValueIndex:t}]of n(this,h))if(e!=t)return!0;return!1};function Ve(e,t={}){const s=class extends Ue{compute(){return e()}};return ee(Ee(new s,{...t,onUse:void 0}))}const ze={visible:!0,horizontal:!1,onVisibleChange:()=>{},onShown:()=>{},onHidden:()=>{},animated:!0,animatedOnInit:!1,className:""},Pe={horizontal:ve};function Re(e){const[{animatedOnInit$:t,animated$:s,visible$:i,onVisibleChange$:a,onHidden$:r,onShown$:f,horizontal$:N,...ne},ae]=fe(ze,e,Pe),oe=ye(Ve(()=>N()?be:_e)),C=he({props:{transition:oe,visible:i,animated:s,animatedOnInit:t,onVisibleChange:a,onHidden:r,onShown:f}}),re=C.stores.visible$,le=C.stores.hidden$;return{...de({...ne,visible$:re,hidden$:le,horizontal$:N}),patch:ae,api:{open:C.api.show,close:C.api.hide,toggle:C.api.toggle},directives:{transitionDirective:pe(C.directives.directive)},actions:{}}}const Te=Re,je=D.forwardRef(function(t,s){const[i,a]=ce(Te,t,"collapse",{});return D.useImperativeHandle(s,()=>a.api,[]),ue.jsx("div",{...me(a.directives.transitionDirective),children:t.children})});export{je as C};
