var ne=(t,e,s)=>{if(!e.has(t))throw TypeError("Cannot "+s)};var r=(t,e,s)=>(ne(t,e,"read from private field"),s?s.call(t):e.get(t)),l=(t,e,s)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,s)},a=(t,e,s,n)=>(ne(t,e,"write to private field"),n?n.call(t,s):e.set(t,s),s);var be=(t,e,s,n)=>({set _(i){a(t,e,i,s)},get _(){return r(t,e,n)}}),f=(t,e,s)=>(ne(t,e,"access private method"),s);var pe;const ee=typeof Symbol=="function"&&Symbol.observable||"@@observable",ue=Symbol(),_=()=>{},H=()=>{};H.unsubscribe=H;const ie=(t,e)=>{const s=t?t[e]:null;return typeof s=="function"?s.bind(t):_},ge=t=>({next:typeof t=="function"?t.bind(null):ie(t,"next"),pause:ie(t,"pause"),resume:ie(t,"resume"),_value:void 0,_valueIndex:0,_paused:!1}),Ie=function(){return this},ce=t=>{if(!t)return H;if(t.unsubscribe===t)return t;const e=typeof t=="function"?()=>t():()=>t.unsubscribe();return e.unsubscribe=e,e},re=new WeakSet,Ne=t=>{let e=t.subscribe;return re.has(e)||(e=(...s)=>ce(t.subscribe(...s)),re.add(e)),e},te=t=>{const e="subscribe"in t?t:t[ee]();return Ne(e)},Re=t=>{let e;return t(s=>e=s)(),e};function Q(t,e){const s=te(t),n=Object.assign(()=>fe(n),e,{subscribe:s,[ee]:Ie});return n}const ve=function(t){this.set(t(ze(()=>fe(this))))};function ae(t,e){return Q(t,typeof e=="function"?{set:e,update:ve}:{...e,set:(e==null?void 0:e.set)??_,update:(e==null?void 0:e.update)??(e!=null&&e.set?ve:_)})}const p=Symbol(),_e=Symbol();let oe=!1;const L=new Set,$e=1e3,le=t=>{if(t>$e)throw new Error("reached maximum number of store changes in one shot")},T=t=>{const e=!oe;e&&(oe=!0);try{return t()}finally{if(e)try{const s=new Map;for(const n of L){const i=s.get(n)??0;le(i),s.set(n,i+1),L.delete(n),n[_e]()}}finally{L.clear(),oe=!1}}},qe=t=>Re(te(t));let A=qe;const fe=t=>A(t),Se=t=>({[t]:!0,[t-1]:!1,0:!1}),$=Symbol(),we=(t,e)=>Object.is(t,e)&&(!t||typeof t!="object")&&typeof t!="function";var m,x,y,g,w,z,j,J,Ue,K,ke,N,B;class he{constructor(e){l(this,J);l(this,K);l(this,N);l(this,m,void 0);l(this,x,void 0);l(this,y,void 0);l(this,g,void 0);l(this,w,void 0);l(this,z,void 0);l(this,j,void 0);a(this,m,new Set),a(this,x,null),a(this,y,!1),a(this,g,1),a(this,z,Se(1)),a(this,j,new WeakMap),this[pe]=!1,a(this,w,e)}[(pe=$,_e)](){const e=r(this,g);for(const s of[...r(this,m)]){if(r(this,y)||r(this,g)!==e)return;s._valueIndex!==0&&f(this,N,B).call(this,s)}}[p](){}equal(e,s){return!this.notEqual(e,s)}notEqual(e,s){return!we(e,s)}pauseSubscribers(){if(!r(this,y)){a(this,y,!0),L.delete(this);for(const e of[...r(this,m)])e._valueIndex===0||e._paused||(e._paused=!0,e.pause())}}resumeSubscribers(){r(this,y)&&(a(this,y,!1),T(()=>{L.add(this)}))}set(e){const s=this[$];if(s||!this.equal(r(this,w),e)){const n=r(this,g)+1;a(this,g,n),a(this,w,e),a(this,z,Se(n)),s&&delete r(this,z)[n-1],this.pauseSubscribers()}this.resumeSubscribers()}update(e){this.set(e(r(this,w)))}onUse(){}subscribe(e){const s=ge(e),n=e==null?void 0:e[ue];if(n){const o=r(this,j).get(n);o&&(s._value=o._value,s._valueIndex=o._valueIndex)}r(this,m).add(s),T(()=>{r(this,m).size==1?f(this,J,Ue).call(this):this[p]()}),f(this,N,B).call(this,s);const i=()=>{const o=r(this,m).delete(s);s.next=_,s.pause=_,s.resume=_,o&&(r(this,j).set(i,s),r(this,m).size===0&&f(this,K,ke).call(this))};return i[p]=()=>{this[p](),f(this,N,B).call(this,s)},i.unsubscribe=i,i}[ee](){return this}}m=new WeakMap,x=new WeakMap,y=new WeakMap,g=new WeakMap,w=new WeakMap,z=new WeakMap,j=new WeakMap,J=new WeakSet,Ue=function(){a(this,x,ce(this.onUse()))},K=new WeakSet,ke=function(){const e=r(this,x);e&&(a(this,x,null),e())},N=new WeakSet,B=function(e){const s=r(this,z),n=r(this,g),i=r(this,w);let o=s[e._valueIndex];o==null&&(o=!!this.equal(e._value,i),s[e._valueIndex]=o),e._valueIndex=n,o?!r(this,y)&&e._paused&&(e._paused=!1,e.resume()):(e._value=i,e._paused=!1,e.next(i))};function Me(t){const e=s=>(s!=null&&s[ue]||ge(s).next(t),H);return re.add(e),Object.assign(()=>t,{subscribe:e,[ee]:Ie})}class Ce extends he{constructor(e){super(e)}set(e){super.set(e)}update(e){super.update(e)}}const se=(t,e)=>{const{onUse:s,equal:n,notEqual:i}=e;return s&&(t.onUse=function(){const o=u=>this.set(u);return o.set=o,o.update=u=>this.update(u),s(o)}),n&&(t.equal=function(o,u){return n(o,u)}),i&&(t.notEqual=function(o,u){return i(o,u)}),t};function Ve(t,e={}){return typeof e=="function"&&(e={onUse:e}),e.onUse?Q(se(new Ce(t),e)):Me(t)}function xe(t,e={}){typeof e=="function"&&(e={onUse:e});const s=se(new Ce(t),e);return Q(s,{set:s.set.bind(s),update:s.update.bind(s)})}function Qe(t){return t.length<=1}const Ee=t=>t();var G,X,v;class me extends he{constructor(s,n){super(n);l(this,G,void 0);l(this,X,void 0);l(this,v,0);const i=Array.isArray(s);a(this,G,i),a(this,X,(i?[...s]:[s]).map(te))}resumeSubscribers(){r(this,v)||super.resumeSubscribers()}onUse(){let s=!1,n=0;const i=r(this,G),o=r(this,X),u=new Array(o.length);let c=null;const S=()=>{const h=c;h&&(c=null,h())},F=(h=!1)=>{h&&(s=!0),s&&!r(this,v)&&(n&&(n=0,S(),c=ce(this.derive(i?u:u[0]))),this.resumeSubscribers())},d=o.map((h,V)=>{const q=je=>{u[V]=je,n|=1<<V,a(this,v,r(this,v)&~(1<<V)),F()};return q.next=q,q.pause=()=>{a(this,v,r(this,v)|1<<V),this.pauseSubscribers()},q.resume=()=>{a(this,v,r(this,v)&~(1<<V)),F()},h(q)}),C=(h,V)=>{var q;r(this,v)&1<<V&&((q=h[p])==null||q.call(h))};return this[p]=()=>{let h=0;for(;r(this,v)&&(le(++h),s=!1,d.forEach(C),!r(this,v));)F(!0)},F(!0),this[p](),()=>{this[p]=_,S(),d.forEach(Ee)}}}G=new WeakMap,X=new WeakMap,v=new WeakMap;function Le(t,e,s){typeof e=="function"&&(e={derive:e});const{derive:n,...i}=e,o=Qe(n)?class extends me{constructor(u,c){super(u,c),this[$]=!0}derive(u){this.set(n(u)),this[$]=!1}}:class extends me{derive(u){const c=S=>this.set(S);return c.set=c,c.update=S=>this.update(S),n(u,c)}};return Q(se(new o(t,s),{...i,onUse:void 0}))}const ze=t=>{const e=A;try{return A=qe,t()}finally{A=e}},Te=({unsubscribe:t})=>t(),Ge=({resubscribe:t})=>t();var R,I,U,b,O,Y,De,Z,Ae,D,E,k,W,P,Fe;class Xe extends he{constructor(){super(void 0);l(this,Y);l(this,Z);l(this,D);l(this,k);l(this,P);l(this,R,!1);l(this,I,!1);l(this,U,0);l(this,b,new Map);l(this,O,s=>ze(()=>f(this,Z,Ae).call(this,s)));this[$]=!0}resumeSubscribers(){f(this,k,W).call(this)||super.resumeSubscribers()}[p](){var n;if(r(this,R))throw new Error("recursive computed");let s=0;for(;f(this,k,W).call(this);){le(++s),a(this,I,!0);try{for(const[,{pending:i,unsubscribe:o}]of r(this,b))i&&((n=o[p])==null||n.call(o))}finally{a(this,I,!1)}if(f(this,k,W).call(this))break;f(this,D,E).call(this)}}onUse(){return f(this,D,E).call(this,!0),this[p](),()=>r(this,b).forEach(Te)}}R=new WeakMap,I=new WeakMap,U=new WeakMap,b=new WeakMap,O=new WeakMap,Y=new WeakSet,De=function(s){const n={versionIndex:r(this,U),unsubscribe:_,resubscribe:_,pending:!1,usedValueIndex:0,value:void 0,valueIndex:0},i=o=>{n.value=o,n.valueIndex++,n.pending=!1,!r(this,I)&&!f(this,k,W).call(this)&&T(()=>f(this,D,E).call(this))};return i.next=i,i.pause=()=>{n.pending=!0,this.pauseSubscribers()},i.resume=()=>{n.pending=!1,!r(this,I)&&!f(this,k,W).call(this)&&T(()=>f(this,D,E).call(this))},n.resubscribe=()=>{n.unsubscribe=s(i),i[ue]=n.unsubscribe},n.resubscribe(),n},Z=new WeakSet,Ae=function(s){var i,o;let n=r(this,b).get(s);return n?(n.versionIndex=r(this,U),(o=(i=n.unsubscribe)[p])==null||o.call(i)):(n=f(this,Y,De).call(this,te(s)),r(this,b).set(s,n)),n.usedValueIndex=n.valueIndex,n.value},D=new WeakSet,E=function(s=!1){a(this,R,!0),a(this,I,!0);try{if(r(this,U)>0&&(s&&r(this,b).forEach(Ge),!f(this,P,Fe).call(this))){this.resumeSubscribers();return}be(this,U)._++;const n=r(this,U),i=A;let o;try{A=r(this,O),o=this.compute()}finally{A=i}this.set(o),this[$]=!1;for(const[u,c]of r(this,b))c.versionIndex!==n&&(r(this,b).delete(u),c.unsubscribe())}finally{a(this,I,!1),a(this,R,!1)}},k=new WeakSet,W=function(){for(const[,{pending:s}]of r(this,b))if(s)return!0;return!1},P=new WeakSet,Fe=function(){for(const[,{valueIndex:s,usedValueIndex:n}]of r(this,b))if(s!=n)return!0;return!1};function M(t,e={}){const s=class extends Xe{compute(){return t()}};return Q(se(new s,{...e,onUse:void 0}))}const Pe=()=>{},We=t=>t,et=t=>({actions:t.actions,api:t.api,directives:t.directives,state$:t.state$,stores:t.stores}),ye=Symbol();function Be(t){return function(e){T(()=>{var s;for(const[n,i]of Object.entries(e??{}))(s=t[`${n}$`])==null||s.set(i)})}}function tt(t,e){if(t===e)return null;let s=!1;const n={},i=new Set([...Object.keys(t),...Object.keys(e)]);for(const o of i){const u=e[o];t[o]!==u&&(n[o]=u,s=!0)}return s?n:null}function He(t,e=Ve(void 0),s={},n=xe(void 0)){const{normalizeValue:i=We,equal:o=Object.is}=s,u=()=>t,c=(d,C=u)=>{const h=d===void 0?void 0:i(d);return h===ye?(console.error("Not using invalid value",d),C()):h===void 0?C():h},S=M(()=>c(e()),{equal:o}),F=M(()=>c(n(),S),{equal:o});return ae(F,d=>{if(d!==void 0){const C=i(d);if(C===ye){console.error("Not setting invalid value",d);return}d=C}n.set(d)})}const de=t=>!!(t&&typeof t=="function"&&"subscribe"in t),Je=t=>de(t)?t:Ve(t),Ke=t=>de(t)?t:xe(t),Oe=(t,e)=>{const s={};if(e){const n=de(e);for(const i of t)s[i]=n?M(()=>e()[i]):Je(e[i])}return s},st=(t,e,s)=>{const n={};for(const i of t){const o=e==null?void 0:e[i],u=s==null?void 0:s[i];n[i]=o&&u?M(()=>o()??u()):o||u}return n},Ye=(t,e,s)=>{const n={},i=Object.keys(t),o=Oe(i,e==null?void 0:e.config),u=e==null?void 0:e.props;for(const c of i){const S=u==null?void 0:u[c];n[`${c}$`]=He(t[c],o[c],s==null?void 0:s[c],Ke(S))}return n},nt=(t,e,s)=>{const n=Ye(t,e,s);return[n,Be(n)]},it=t=>{const e=[],s=[],n={};for(const[i,o]of Object.entries(t))i.endsWith("$")&&(e.push(i.substring(0,i.length-1)),s.push(o),n[i]=Q(o));return{stores:n,state$:M(()=>{const i=s.map(fe),o={};return e.forEach((u,c)=>{o[u]=i[c]}),o})}},ot=(t,e,s=i=>i[0],n=(i,o)=>o===i)=>{let i=e[0]();return ae(Le(e,{derive(o){const u=s(o),c=!n(o[0],u);return c&&e[0].set(u),(c||!n(i,u))&&(i=u,t()(u)),u},equal:n}),e[0].set.bind(e[0]))},rt=(t,e,s=We,n=we)=>ae(M(()=>s(t()),{equal:n}),i=>{const o=s(i);n(t(),o)||(t.set(o),e()(o))});export{ye as I,xe as a,Pe as b,M as c,Q as d,T as e,Je as f,ae as g,Ye as h,We as i,de as j,tt as k,ot as l,st as m,Oe as n,Le as o,we as p,rt as q,Ve as r,it as s,et as t,nt as w};
