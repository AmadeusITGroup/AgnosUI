{"type":"data","nodes":[null,{"type":"data","data":[{"includesFwk":1,"includesPkg":1,"menu":2,"since":145},true,[3,6,9,60,103,122],{"title":4,"path":5,"submenu":-1},"Types","api/svelte/headless/types",{"title":7,"path":8,"submenu":-1},"Config","api/svelte/headless/config",{"title":10,"path":-1,"submenu":11},"Components",[12,16,20,24,28,32,36,40,44,48,52,56],{"path":13,"slug":14,"label":15},"api/svelte/headless/components/accordion","components/accordion","Accordion",{"path":17,"slug":18,"label":19},"api/svelte/headless/components/alert","components/alert","Alert",{"path":21,"slug":22,"label":23},"api/svelte/headless/components/carousel","components/carousel","Carousel",{"path":25,"slug":26,"label":27},"api/svelte/headless/components/collapse","components/collapse","Collapse",{"path":29,"slug":30,"label":31},"api/svelte/headless/components/modal","components/modal","Modal",{"path":33,"slug":34,"label":35},"api/svelte/headless/components/pagination","components/pagination","Pagination",{"path":37,"slug":38,"label":39},"api/svelte/headless/components/progressbar","components/progressbar","Progressbar",{"path":41,"slug":42,"label":43},"api/svelte/headless/components/rating","components/rating","Rating",{"path":45,"slug":46,"label":47},"api/svelte/headless/components/select","components/select","Select",{"path":49,"slug":50,"label":51},"api/svelte/headless/components/slider","components/slider","Slider",{"path":53,"slug":54,"label":55},"api/svelte/headless/components/toast","components/toast","Toast",{"path":57,"slug":58,"label":59},"api/svelte/headless/components/tree","components/tree","Tree",{"title":61,"path":-1,"submenu":62},"Services",[63,67,71,75,79,83,87,91,95,99],{"path":64,"slug":65,"label":66},"api/svelte/headless/services/extendWidget","services/extendWidget","extendWidget",{"path":68,"slug":69,"label":70},"api/svelte/headless/services/floatingUI","services/floatingUI","floatingUI",{"path":72,"slug":73,"label":74},"api/svelte/headless/services/focustrack","services/focustrack","focustrack",{"path":76,"slug":77,"label":78},"api/svelte/headless/services/hash","services/hash","hash",{"path":80,"slug":81,"label":82},"api/svelte/headless/services/intersection","services/intersection","intersection",{"path":84,"slug":85,"label":86},"api/svelte/headless/services/matchMedia","services/matchMedia","matchMedia",{"path":88,"slug":89,"label":90},"api/svelte/headless/services/navManager","services/navManager","navManager",{"path":92,"slug":93,"label":94},"api/svelte/headless/services/portal","services/portal","portal",{"path":96,"slug":97,"label":98},"api/svelte/headless/services/resizeObserver","services/resizeObserver","resizeObserver",{"path":100,"slug":101,"label":102},"api/svelte/headless/services/siblingsInert","services/siblingsInert","siblingsInert",{"title":104,"path":-1,"submenu":105},"Transitions",[106,110,114,118],{"path":107,"slug":108,"label":109},"api/svelte/headless/services/transitions/baseTransitions","services/transitions/baseTransitions","baseTransitions",{"path":111,"slug":112,"label":113},"api/svelte/headless/services/transitions/collapse","services/transitions/collapse","collapse",{"path":115,"slug":116,"label":117},"api/svelte/headless/services/transitions/cssTransitions","services/transitions/cssTransitions","cssTransitions",{"path":119,"slug":120,"label":121},"api/svelte/headless/services/transitions/simpleClassTransition","services/transitions/simpleClassTransition","simpleClassTransition",{"title":123,"path":-1,"submenu":124},"Utils",[125,129,133,137,141],{"path":126,"slug":127,"label":128},"api/svelte/headless/utils/directive","utils/directive","directive",{"path":130,"slug":131,"label":132},"api/svelte/headless/utils/func","utils/func","func",{"path":134,"slug":135,"label":136},"api/svelte/headless/utils/stores","utils/stores","stores",{"path":138,"slug":139,"label":140},"api/svelte/headless/utils/widget","utils/widget","widget",{"path":142,"slug":143,"label":144},"api/svelte/headless/utils/writables","utils/writables","writables","v0.4.0"],"uses":{"params":["framework","type"]}},{"type":"data","data":[{"slug":1,"content":2,"title":60,"import":61},"utils/stores",[3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57],{"source":4,"name":5},"## function_bindableDerived\n> **bindableDerived**\\\u003C`T`, `U`\\>(`onChange$`, `stores`, `adjustValue`, `equal`): [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`\\>\n\n\nCreates a writable signal that derives its value from multiple stores and allows for custom adjustment and equality checks.\n\n### Type Parameters\n\n#### T\n\n`T`\n\nThe type of the derived value.\n\n#### U\n\n`U` *extends* \\[[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T`\\>, `...StoreInput\u003Cany>[]`\\]\n\nA tuple type where the first element is a writable signal of type T and the rest are store inputs.\n\n### Parameters\n\n#### onChange$\n\n[`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C(`value`) => `void`\\>\n\nA readable signal that emits a function to be called when the derived value changes.\n\n#### stores\n\n`U`\n\nA tuple of stores where the first element is a writable signal of type T and the rest are store inputs.\n\n#### adjustValue\n\n(`arg`) => `T`\n\nA function to adjust the derived value based on the input values from the stores.\n\n#### equal\n\n(`currentValue`, `newValue`) => `boolean`\n\nA function to compare the current and new values for equality.\n\n### Returns\n\n[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`\\>\n\nA writable signal that derives its value from the provided stores and allows for custom adjustment and equality checks.\n","bindableDerived",{"source":7,"name":8},"## function_bindableProp\n> **bindableProp**\\\u003C`T`\\>(`store$`, `onChange$`, `adjustValue?`, `equal?`): [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`\\>\n\n\nCreates a bindable property that synchronizes a writable signal with an optional adjustment function and equality check.\n\n### Type Parameters\n\n#### T\n\n`T`\n\nThe type of the value being stored.\n\n### Parameters\n\n#### store$\n\n[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `undefined` \\| `T`\\>\n\nThe writable signal that holds the current value.\n\n#### onChange$\n\n[`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C(`newValue`) => `void`\\>\n\nA readable signal that triggers a callback when the value changes.\n\n#### adjustValue?\n\n(`value`) => `T`\n\nAn optional function to adjust the value before storing it. Defaults to the identity function.\n\n#### equal?\n\n(`a`, `b`) => `boolean`\n\nAn optional function to compare values for equality. Defaults to `tansuDefaultEqual`.\n\n### Returns\n\n[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`\\>\n\nA writable signal that synchronizes with the provided store and triggers the onChange callback when updated.\n","bindableProp",{"source":10,"name":11},"## function_createPatch\n> **createPatch**\\\u003C`T`\\>(`stores`): (`storesValues`) => `void`\n\n\nUtility function designed to create a `patch` function related to the provided stores.\nAny key given to the patch function which is not in the original object will be ignored.\n\n### Type Parameters\n\n#### T\n\n`T` *extends* `object`\n\nThe type of the object that the stores represent.\n\n### Parameters\n\n#### stores\n\n[`ToWritableSignal`](#towritablesignal)\\\u003C`T`\\>\n\nThe stores to be updated.\n\n### Returns\n\n- A function that takes partial values of the stores and updates them.\n\n> (`storesValues`): `void`\n\n#### Parameters\n\n##### storesValues\n\n[`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\>\n\n#### Returns\n\n`void`\n\n### Example\n\n```typescript\nconst storeA$ = writable(1);\nconst storeB$ = writable(1);\nconst patch = createPatch({a: storeA$, b: storeB$});\n\npatch({a: 2}) // will perform storeA$.set(2)\npatch({a: 2, b: 2}) // will perform storeA$.set(2) and storeB$.set(2) in the same batch.\npatch({a: 2, c: 2}) // will perform storeA$.set(2), c is ignored.\n\n```\n","createPatch",{"source":13,"name":14},"## constant_false$\n> `const` **false$**: [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`false`\\>\n\n","false$",{"source":16,"name":17},"## function_findChangedProperties\n> **findChangedProperties**\\\u003C`T`\\>(`obj1`, `obj2`): `null` \\| [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\>\n\n\nThis utility function is designed to compare the first level of two objects.\n\nIt returns a new object which has all the keys for which the values in `obj1`\nand `obj2` are different, with the values from `obj2`, or null if objects\nare identical.\n\n### Type Parameters\n\n#### T\n\n`T` *extends* [`Record`](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)\\\u003C`string`, `any`\\>\n\nThe type of the objects being compared.\n\n### Parameters\n\n#### obj1\n\n[`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\>\n\nThe first partial object to compare.\n\n#### obj2\n\n[`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\>\n\nThe second partial object to compare.\n\n### Returns\n\n`null` \\| [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\>\n\nA partial object containing the properties that have different values, or `null` if the objects are identical.\n","findChangedProperties",{"source":19,"name":20},"## function_idWithDefault\n> **idWithDefault**(`id$`): [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`string`\\>\n\n\nWraps an id store in a computed so that undefined and empty values are replaced by a generated id.\n\n### Parameters\n\n#### id$\n\n[`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`string`\\>\n\nthe id store to use\n\n### Returns\n\n[`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`string`\\>\n\nthe id store with a default generation if the id is not provided\n","idWithDefault",{"source":22,"name":23},"## function_isStore\n> **isStore**(`x`): `x is ReadableSignal\u003Cany>`\n\n\nReturns true if the provided argument is a store (ReadableSignal).\n\n### Parameters\n\n#### x\n\n`any`\n\nargument that is tested\n\n### Returns\n\n`x is ReadableSignal\u003Cany>`\n\ntrue if the argument is a store (ReadableSignal)\n","isStore",{"source":25,"name":26},"## function_mergeConfigStores\n> **mergeConfigStores**\\\u003C`T`\\>(`keys`, `config1?`, `config2?`): [`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\n\nMerges two configuration stores into one, prioritizing the first store's values\nwhen both stores have a value for the same key.\n\n### Type Parameters\n\n#### T\n\n`T` *extends* `object`\n\nThe type of the configuration object.\n\n### Parameters\n\n#### keys\n\nkeyof `T`[]\n\nThe keys to merge from the configuration stores.\n\n#### config1?\n\n[`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\nThe first configuration store.\n\n#### config2?\n\n[`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\nThe second configuration store.\n\n### Returns\n\n[`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\n- The merged configuration store.\n","mergeConfigStores",{"source":28,"name":29},"## function_normalizeConfigStores\n> **normalizeConfigStores**\\\u003C`T`\\>(`keys`, `config?`): [`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\n\nNormalizes configuration stores by converting them into readable signals.\n\n### Type Parameters\n\n#### T\n\n`T` *extends* `object`\n\nThe type of the configuration object.\n\n### Parameters\n\n#### keys\n\nkeyof `T`[]\n\nAn array of keys to normalize from the configuration object.\n\n#### config?\n\nThe configuration object or readable signals to normalize.\n\n[`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C[`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)\\\u003C`T`\\>\\> | [`ValuesOrReadableSignals`](../types#valuesorreadablesignals)\\\u003C`T`\\>\n\n### Returns\n\n[`ReadableSignals`](#readablesignals)\\\u003C`T`\\>\n\nAn object containing readable signals for each key in the configuration.\n","normalizeConfigStores",{"source":31,"name":32},"## type alias_ReadableSignals\n> **ReadableSignals**\\\u003C`T`\\> = \\{ \\[K in keyof T\\]?: ReadableSignal\\\u003CT\\[K\\] \\| undefined\\> \\}\n\n\nRepresents a collection of readable signals for an object type `T`.\nEach key in the object corresponds to a key in `T`, and the value is an optional `ReadableSignal`\nthat can hold the value of the corresponding property in `T` or `undefined`.\n\n### Type Parameters\n\n#### T\n\n`T` *extends* `object`\n\nThe object type for which the readable signals are defined.\n","ReadableSignals",{"source":34,"name":35},"## function_stateStores\n> **stateStores**\\\u003C`A`\\>(`inputStores`): `object`\n\n\nUsing input stores, this function builds an object containing the stores as readable and a global state.\n\n### Type Parameters\n\n#### A\n\n`A` *extends* `object`\n\nThe type of the state object.\n\n### Parameters\n\n#### inputStores\n\n\\{ \\[K in string \\| number \\| symbol as \\`$\\{K & string\\}$\\`\\]: ReadableSignal\\\u003Cany\\> \\}\n\nthe input stores\n\n### Returns\n\n`object`\n\nthe object containing the stores as readable and the global state\n\n#### state$\n\n> **state$**: [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`A`\\>\n\n#### stores\n\n> **stores**: \\{ \\[K in string \\| number \\| symbol as \\`$\\{K & string\\}$\\`\\]: ReadableSignal\\\u003CA\\[K\\]\\> \\}\n","stateStores",{"source":37,"name":38},"## function_toReadableStore\n> **toReadableStore**\\\u003C`T`\\>(`x`): [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`T`\\>\n\n\nIf the provided argument is already a store, it is returned as is, otherwise, a readable store is created with the provided argument as its initial value.\n\n### Type Parameters\n\n#### T\n\n`T`\n\nThe type of the value.\n\n### Parameters\n\n#### x\n\nThe value to be converted to a readable store.\n\n`T` | [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`T`\\>\n\n### Returns\n\n[`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`T`\\>\n\n- The readable store containing the value.\n","toReadableStore",{"source":40,"name":41},"## type alias_ToWritableSignal\n> **ToWritableSignal**\\\u003C`P`\\> = \\{ \\[K in keyof P as \\`$\\{K & string\\}$\\`\\]-?: WritableSignal\\\u003CP\\[K\\], P\\[K\\] \\| undefined\\> \\}\n\n\nTransforms the properties of a given type `P` into writable signals.\nEach property key in `P` is suffixed with a `$` and its type is converted to a `WritableSignal`.\n\n### Type Parameters\n\n#### P\n\n`P`\n\nThe original type whose properties are to be transformed.\n","ToWritableSignal",{"source":43,"name":44},"## function_toWritableStore\n> **toWritableStore**\\\u003C`T`\\>(`x`): [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`\\>\n\n\nConverts a value or a writable signal into a writable signal.\n\n### Type Parameters\n\n#### T\n\n`T`\n\nThe type of the value or signal.\n\n### Parameters\n\n#### x\n\nThe value or writable signal to convert.\n\n`T` | [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `T`\\>\n\n### Returns\n\n[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`\\>\n\n- The resulting writable signal.\n","toWritableStore",{"source":46,"name":47},"## constant_true$\n> `const` **true$**: [`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`true`\\>\n\n","true$",{"source":49,"name":50},"## type alias_WithoutDollar\n> **WithoutDollar**\\\u003C`S`\\> = `S` *extends* `` `${infer U}$` `` ? `U` : `never`\n\n\nA utility type that removes the trailing dollar sign (`$`) from a string type.\n\n### Type Parameters\n\n#### S\n\n`S` *extends* `` `${string}$` ``\n\nA string type that ends with a dollar sign (`$`).\n\n### Returns\n\nThe string type without the trailing dollar sign (`$`), or `never` if the input type does not end with a dollar sign.\n","WithoutDollar",{"source":52,"name":53},"## function_writablesForProps\n> **writablesForProps**\\\u003C`T`\\>(`defConfig`, `propsConfig?`, `options?`): \\[[`ToWritableSignal`](#towritablesignal)\\\u003C`T`\\>, (`storesValues`) => `void`\\]\n\n\nShortcut for calling both [writablesWithDefault](#writableswithdefault) and [createPatch](#createpatch) in one call.\n\n### Type Parameters\n\n#### T\n\n`T` *extends* `object`\n\nThe type of the properties configuration object.\n\n### Parameters\n\n#### defConfig\n\n`T`\n\nobject containing, for each property, a default value to use in case `config` does not provide the suitable default\nvalue for that property\n\n#### propsConfig?\n\n[`PropsConfig`](../types#propsconfig)\\\u003C`T`\\>\n\neither a store of objects containing, for each property of `defConfig`, the default value or an object containing\nfor each property of `defConfig` either a store containing the default value or the default value itself\n\n#### options?\n\n\\{ \\[K in string \\| number \\| symbol\\]: undefined \\| WritableWithDefaultOptions\\\u003CT\\[K\\]\\> \\}\n\nobject containing, for each property of `defConfig`, an optional object with the following optional functions: normalizeValue and equal\n\n### Returns\n\n\\[[`ToWritableSignal`](#towritablesignal)\\\u003C`T`\\>, (`storesValues`) => `void`\\]\n\nan array with two items: the first one containing the writables (returned by [writablesWithDefault](#writableswithdefault)),\nand the second one containing the patch function (returned by [createPatch](#createpatch))\n\n### Examples\n\n```ts\nconst defConfig = {propA: 1};\nconst validation = {propA: {normalizeValue: value => +value}};\nconst config$ = writable({propA: 5});\nconst [{propA$}, patch] = writablesForProps(defConfig, config$, validation);\n```\n\n```ts\nconst defConfig = {propA: 1, propB: 2};\nconst validation = {propA: {normalizeValue: value => +value}};\nconst config = {propA: 5, propB: writable(3)};\nconst [{propA$, propB$}, patch] = writablesForProps(defConfig, config, validation);\n```\n","writablesForProps",{"source":55,"name":56},"## function_writablesWithDefault\n> **writablesWithDefault**\\\u003C`T`\\>(`defConfig`, `propsConfig?`, `options?`): [`ToWritableSignal`](#towritablesignal)\\\u003C`T`\\>\n\n\nReturns an object containing, for each property of `defConfig`, a corresponding writable with the normalization and default value logic\ndescribed in [writableWithDefault](#writablewithdefault). Keys in the returned object are the same as the ones present in `defConfig`,\nwith the exta `$` suffix (showing that they are stores).\n\n### Type Parameters\n\n#### T\n\n`T` *extends* `object`\n\nThe type of the default configuration object.\n\n### Parameters\n\n#### defConfig\n\n`T`\n\nobject containing, for each property, a default value to use in case `config$` does not provide the suitable default\nvalue for that property\n\n#### propsConfig?\n\n[`PropsConfig`](../types#propsconfig)\\\u003C`T`\\>\n\nobject defining the config and props\n\n#### options?\n\n[`ConfigValidator`](../types#configvalidator)\\\u003C`T`\\>\n\nobject containing, for each property of `defConfig`, an optional object with the following optional functions: normalizeValue and equal\n\n### Returns\n\n[`ToWritableSignal`](#towritablesignal)\\\u003C`T`\\>\n\nan object containing writables\n\n### Examples\n\n```ts\nconst defConfig = {propA: 1};\nconst validation = {propA: {normalizeValue: value => +value}};\nconst config = writable({propA: 5});\nconst {propA$} = writablesWithDefault(defConfig, {config}, validation);\n```\n\n```ts\nconst defConfig = {propA: 1, propB: 2};\nconst validation = {propA: {normalizeValue: value => +value}};\nconst config = {propA: 5, propB: writable(3)};\nconst {propA$, propB$} = writablesWithDefault(defConfig, {config}, validation);\n```\n","writablesWithDefault",{"source":58,"name":59},"## function_writableWithDefault\n> **writableWithDefault**\\\u003C`T`\\>(`defValue`, `config$`, `options`, `own$`): [`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `undefined` \\| `T`\\>\n\n\nReturns a writable store whose value is either its own value (when it is not undefined) or a default value\nthat comes either from the `config$` store (when it is not undefined) or from `defValue`.\nIf a normalizeValue function is passed in the options, it is called to normalize non-undefined values coming\neither from the `config$` store or from the `set` or `update` functions. If a value is invalid (i.e. normalizeValue\nreturns the `invalidValue` symbol), an error is logged on the console and it is either not set (if it comes from the\n`set` or `update` functions), or the `defValue` is used instead (if the invalid value comes from the `config$` store).\n\n### Type Parameters\n\n#### T\n\n`T`\n\nThe type of the value.\n\n### Parameters\n\n#### defValue\n\n`T`\n\nDefault value used when both the own value and the config$ value are undefined.\n\n#### config$\n\n[`ReadableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/ReadableSignal.html)\\\u003C`undefined` \\| `T`\\> = `...`\n\nStore containing the default value used when the own value is undefined\n\n#### options\n\n[`WritableWithDefaultOptions`](../types#writablewithdefaultoptions)\\\u003C`T`\\> = `{}`\n\nObject which can contain the following optional functions: normalizeValue and equal\n\n#### own$\n\n[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`undefined` \\| `T`\\> = `...`\n\nStore containing the own value\n\n### Returns\n\n[`WritableSignal`](https://amadeusitgroup.github.io/tansu/interfaces/WritableSignal.html)\\\u003C`T`, `undefined` \\| `T`\\>\n\na writable store with the extra default value and normalization logic described above\n","writableWithDefault","API stores","@agnos-ui/svelte-headless/utils/stores"],"uses":{"params":["framework","type","slug"]}}]}
